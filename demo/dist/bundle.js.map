{
  "version": 3,
  "sources": ["../app.tsx", "../mockFetch.ts", "../../src/router.tsx", "../../node_modules/@babel/runtime/helpers/esm/extends.js", "../../node_modules/history/index.js", "../../src/history.ts", "../../src/helper.ts", "../../src/handleHistoryChange.ts", "../routes.tsx", "../reducer.ts"],
  "sourcesContent": ["import React, { createContext, useReducer } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\n// \u2B07\uFE0F mock backend\nimport { installMockFetch } from \"./mockFetch\";\ninstallMockFetch();\n\nimport { createRouter } from \"../src\";\nimport routesMap from \"./routes\";\nimport reducer, { initialState } from \"./reducer\";\n\n// --- Store is REQUIRED ---\ntype DemoStoreContextValue = {\n  state: Record<string, unknown>;\n  dispatch: React.Dispatch<Record<string, unknown>> | false;\n};\n\nexport const StateContext = createContext<DemoStoreContextValue>({\n  state: initialState,\n  dispatch: false,\n});\n\nconst StateProvider = ({ children }: { children: React.ReactNode }) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <StateContext.Provider value={{ state, dispatch }}>\n      {children}\n    </StateContext.Provider>\n  );\n};\n\n// Router now takes (routes, storeContext)\nconst AppRouter = createRouter(routesMap, StateContext);\n\nconst rootElement = document.getElementById(\"root\");\nif (!rootElement) {\n  throw new Error(\"Missing #root element in demo/index.html\");\n}\n\nconst root = createRoot(rootElement);\nroot.render(\n  <StateProvider>\n    <AppRouter />\n  </StateProvider>,\n);\n", "type MockPage = {\n  title: string;\n  pageData: Record<string, unknown>;\n};\n\ntype InstallMockFetchOptions = {\n  latency?: number;\n};\n\nconst toUrlString = (input: RequestInfo | URL): string => {\n  if (typeof input === \"string\") return input;\n  if (input instanceof URL) return input.toString();\n  return input.url;\n};\n\nexport function installMockFetch({ latency = 120 }: InstallMockFetchOptions = {}): void {\n  // simple in-memory routes\n  const staticPages: Record<string, MockPage> = {\n    \"/\": { title: \"Home\", pageData: { blurb: \"Welcome to the demo.\" } },\n    \"/about\": {\n      title: \"About\",\n      pageData: { blurb: \"This is a mock backend.\" },\n    },\n  };\n  const userRoute = /^\\/users\\/([^/]+)$/;\n\n  globalThis.fetch = async (reqUrl: RequestInfo | URL): Promise<Response> => {\n    const u = new URL(toUrlString(reqUrl), location.origin);\n    const path = u.pathname; // ignore the ?uuid param we add\n    let status = 200;\n    let data: MockPage | undefined = staticPages[path];\n\n    if (!data) {\n      const m = path.match(userRoute);\n      if (m) {\n        const id = m[1];\n        data = { title: `User ${id}`, pageData: { id, role: \"tester\" } };\n      }\n    }\n    if (!data) {\n      status = 404;\n      data = { title: \"Not Found\", pageData: { path } };\n    }\n\n    // simulate network\n    await new Promise((r) => setTimeout(r, latency));\n\n    return new Response(JSON.stringify(data), {\n      status,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  };\n}\n", "import React, {\n  useContext,\n  useMemo,\n  useRef,\n  useSyncExternalStore,\n  type AnchorHTMLAttributes,\n  type ComponentType,\n  type Context,\n  type MouseEvent,\n} from \"react\";\nimport type { BrowserHistory } from \"history\";\nimport history from \"./history\";\nimport helper, {\n  type PreparedRoute,\n  type RouteMatchResult,\n  type RoutesInput,\n} from \"./helper\";\n\nexport type LinkTo =\n  | string\n  | {\n      pathname: string;\n      search?: string;\n      hash?: string;\n    };\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: unknown;\n}\n\nexport interface LinkProps\n  extends Omit<AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  to: LinkTo;\n  replace?: boolean;\n  state?: unknown;\n}\n\ninterface StoreContextValue {\n  state: Record<string, any>;\n  dispatch: ((action: Record<string, unknown>) => void) | false;\n  pageRefresher?: unknown;\n}\n\nconst appHistory: BrowserHistory | null = history;\n\nconst getHistoryOrThrow = (): BrowserHistory => {\n  if (!appHistory) {\n    throw new Error(\n      \"History is unavailable in this environment. Use makeMemoryHistory for non-browser usage.\",\n    );\n  }\n  return appHistory;\n};\n\nexport const navigate = (to: LinkTo, options: NavigateOptions = {}): void => {\n  const { replace = false, state } = options;\n  const activeHistory = getHistoryOrThrow();\n  if (replace) activeHistory.replace(to, state);\n  else activeHistory.push(to, state);\n};\n\nconst toHref = (to: LinkTo): string => {\n  if (typeof to === \"string\") return to;\n  const { pathname, search = \"\", hash = \"\" } = to;\n  if (typeof pathname !== \"string\" || pathname.length === 0) {\n    throw new TypeError(\"Location object 'pathname' must be a non-empty string\");\n  }\n  return `${pathname}${search}${hash}`;\n};\n\nconst isHttpLikeHref = (href: string): boolean => {\n  if (href.startsWith(\"//\")) return false;\n  if (\n    href.startsWith(\"/\") ||\n    href.startsWith(\"./\") ||\n    href.startsWith(\"../\") ||\n    href.startsWith(\"?\") ||\n    href.startsWith(\"#\")\n  ) {\n    return true;\n  }\n  const protocolMatch = href.match(/^([a-zA-Z][a-zA-Z\\d+.-]*):/);\n  if (!protocolMatch) return true;\n  const protocol = protocolMatch[1].toLowerCase();\n  if (protocol !== \"http\" && protocol !== \"https\") return false;\n  if (typeof window === \"undefined\" || !window.location) return false;\n  try {\n    return new URL(href, window.location.href).origin === window.location.origin;\n  } catch {\n    return false;\n  }\n};\n\nconst toClientPath = (to: LinkTo, href: string): LinkTo => {\n  if (typeof to !== \"string\") return to;\n  if (!/^https?:/i.test(href)) return to;\n  try {\n    const url = new URL(href, window.location.href);\n    return `${url.pathname}${url.search}${url.hash}`;\n  } catch {\n    return to;\n  }\n};\n\nconst shouldHandleClientNavigation = (\n  event: MouseEvent<HTMLAnchorElement>,\n  anchorProps: { target?: string; download?: string; href: string },\n): boolean => {\n  if (\n    event.defaultPrevented ||\n    event.button !== 0 ||\n    event.metaKey ||\n    event.altKey ||\n    event.ctrlKey ||\n    event.shiftKey\n  ) {\n    return false;\n  }\n  const { target, download, href } = anchorProps;\n  if (download !== undefined) return false;\n  if (target && target !== \"_self\") return false;\n  return isHttpLikeHref(href);\n};\n\nexport const Link: React.FC<LinkProps> = ({\n  to,\n  replace = false,\n  state,\n  onClick,\n  ...rest\n}) => {\n  const href = toHref(to);\n\n  const handleClick = (e: MouseEvent<HTMLAnchorElement>): void => {\n    if (onClick) onClick(e);\n    if (!shouldHandleClientNavigation(e, { ...rest, href })) return;\n    e.preventDefault();\n    const activeHistory = getHistoryOrThrow();\n    const nextTo = toClientPath(to, href);\n    if (replace) activeHistory.replace(nextTo, state);\n    else activeHistory.push(nextTo, state);\n  };\n\n  return <a href={href} onClick={handleClick} {...rest} />;\n};\n\nconst matchRoute = (\n  routes: RoutesInput | PreparedRoute[],\n  pathname: string,\n): RouteMatchResult => helper.match(routes, pathname);\n\nexport const createRouter = (\n  routes: RoutesInput,\n  storeContext?: Context<StoreContextValue>,\n): React.FC<Record<string, any>> => {\n  const Router: React.FC<Record<string, any>> = (props) => {\n    const appState: StoreContextValue =\n      (storeContext && useContext(storeContext)) || { state: props, dispatch: false };\n\n    const { pageRefresher } = appState;\n    const { state, dispatch } = appState;\n\n    const preparedRoutes = useMemo(() => helper.prepare(routes), [routes]);\n\n    const readHistoryLocation = (): string =>\n      (history?.location?.pathname || \"\") + (history?.location?.search || \"\");\n    const initialLocation = (state && state.location) || readHistoryLocation();\n    const lastLocRef = useRef(initialLocation);\n    const hasNavigationRef = useRef(false);\n    const getLocationSnapshot = (): string =>\n      hasNavigationRef.current ? readHistoryLocation() : initialLocation;\n\n    const loc = useSyncExternalStore(\n      (onStoreChange) => {\n        if (!history || typeof history.listen !== \"function\") return () => {};\n        const unlisten = history.listen(({ location, action }) => {\n          const nextLoc = (location.pathname || \"\") + (location.search || \"\");\n          if (nextLoc !== lastLocRef.current) {\n            lastLocRef.current = nextLoc;\n            hasNavigationRef.current = true;\n            if (typeof dispatch === \"function\") {\n              dispatch({\n                type: \"LOCATION_CHANGED\",\n                location: nextLoc,\n                meta: { action },\n              });\n            }\n          }\n          onStoreChange();\n        });\n        return () => {\n          if (typeof unlisten === \"function\") unlisten();\n        };\n      },\n      getLocationSnapshot,\n      getLocationSnapshot,\n    );\n\n    const activePathname = (loc || \"\").split(\"?\")[0];\n    const matched = useMemo(\n      () => matchRoute(preparedRoutes, activePathname),\n      [preparedRoutes, activePathname],\n    );\n\n    const Component: ComponentType<any> = matched?.Component || (() => null);\n    const routeParams = matched?.params || {};\n\n    return (\n      <Component\n        {...state}\n        {...routeParams}\n        dispatch={dispatch}\n        pageRefresher={pageRefresher}\n      />\n    );\n  };\n\n  return Router;\n};\n\nexport default createRouter;\n", "function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };", "import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "// Modernized history singleton with test-friendly exports (ESM)\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  type BrowserHistory,\n  type MemoryHistory,\n} from \"history\";\n\nexport const appHistory: BrowserHistory | null =\n  typeof window !== \"undefined\" &&\n  window.document &&\n  typeof window.document.createElement === \"function\"\n    ? createBrowserHistory()\n    : null;\n\nexport const makeMemoryHistory = (initialEntries: string[] = [\"/\"]): MemoryHistory =>\n  createMemoryHistory({ initialEntries });\n\nexport default appHistory;\n", "// src/helper.ts\n// Route preparation & matching utility for Universal Route.\n// Accepts either an array of route objects OR a map of { \"/path\": Component | [Component, reducerKey] }.\nimport type { ComponentType } from \"react\";\n\nexport interface RouteDefinition {\n  path: string;\n  Component?: ComponentType<any>;\n  element?: ComponentType<any>;\n  render?: ComponentType<any>;\n  reducerKey?: string;\n}\n\nexport type RouteMapValue =\n  | ComponentType<any>\n  | [ComponentType<any>]\n  | [ComponentType<any>, string]\n  | {\n      Component?: ComponentType<any>;\n      element?: ComponentType<any>;\n      render?: ComponentType<any>;\n      reducerKey?: string;\n    };\n\nexport type RouteMap = Record<string, RouteMapValue>;\n\nexport type RoutesInput = RouteDefinition[] | RouteMap;\n\nexport interface PreparedRoute {\n  path: string;\n  Component: ComponentType<any>;\n  reducerKey?: string;\n  matcher: (pathname: string) => { params: Record<string, string> } | null;\n}\n\nexport interface RouteMatchResult {\n  Component: ComponentType<any>;\n  params: Record<string, string>;\n  reducerKey?: string;\n}\n\ntype NormalizedRoute = {\n  path: string;\n  Component: ComponentType<any>;\n  reducerKey?: string;\n};\n\nconst isPreparedRouteArray = (\n  routes: RoutesInput | PreparedRoute[],\n): routes is PreparedRoute[] =>\n  Array.isArray(routes) &&\n  routes.every((route) => typeof route === \"object\" && typeof (route as PreparedRoute).matcher === \"function\");\n\nconst escapeRegex = (s: string): string => s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\nconst decodeParam = (value: string): string => {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n};\n\n// Compile a path pattern like \"/users/:id\" into a RegExp with capture groups.\n// Supports \"*\" or \"/*\" catch-all and \":param+\" rest parameters.\nconst compilePath = (path: string): { regex: RegExp; names: string[] } => {\n  if (!path || path === \"/\") {\n    return { regex: /^\\/?$/, names: [] };\n  }\n  if (path === \"*\" || path === \"/*\") {\n    return { regex: /^.*$/, names: [] };\n  }\n\n  const parts: Array<{ src: string; name: string | null }> = String(path)\n    .split(\"/\")\n    .filter(Boolean)\n    .map((part) => {\n      if (part.startsWith(\":\")) {\n        const raw = part.slice(1).trim();\n        const modifier = raw[raw.length - 1];\n        const hasModifier = modifier === \"+\" || modifier === \"*\" || modifier === \"?\";\n        const name = (hasModifier ? raw.slice(0, -1) : raw).trim();\n\n        if (!name) {\n          throw new TypeError(`Invalid route param segment \\\"${part}\\\" in path \\\"${path}\\\"`);\n        }\n\n        // Use plain captures so invalid JS identifier characters in route params do not break regex compilation.\n        const src = modifier === \"+\" ? \"(.+)\" : \"([^/]+)\";\n        return { src, name };\n      }\n      return { src: escapeRegex(part), name: null };\n    });\n\n  const pattern = \"^/\" + parts.map((p) => p.src).join(\"/\") + \"/?$\";\n  const names = parts.filter((p) => p.name).map((p) => p.name as string);\n  return { regex: new RegExp(pattern), names };\n};\n\n// Graceful 404 Component that renders the text \"404\" (no React import required)\nconst Generic404 = (): string => \"404\";\n\n// Normalize a single map entry: (path, value) -> { path, Component, reducerKey }\nconst normalizeMapEntry = (path: string, value: RouteMapValue): NormalizedRoute => {\n  let Component: ComponentType<any>;\n  let reducerKey: string | undefined;\n\n  if (Array.isArray(value)) {\n    [Component, reducerKey] = value;\n  } else if (typeof value === \"function\") {\n    Component = value;\n  } else if (value && typeof value === \"object\") {\n    Component = value.Component || value.element || value.render || (() => null);\n    reducerKey = value.reducerKey;\n  } else {\n    Component = () => null;\n  }\n\n  return { path, Component, reducerKey };\n};\n\n// Normalize a route object from array form: { path, Component | element | render, reducerKey? }\nconst normalizeArrayEntry = (routeObj: RouteDefinition = { path: \"/\" }): NormalizedRoute => {\n  const { path = \"/\", reducerKey } = routeObj;\n  const Component = routeObj.Component || routeObj.element || routeObj.render || (() => null);\n  return { path, Component, reducerKey };\n};\n\n// Convert routes (array or map) into a uniform list of { path, Component, reducerKey }\nconst toList = (routes: RoutesInput): NormalizedRoute[] => {\n  if (Array.isArray(routes)) {\n    return routes.map(normalizeArrayEntry);\n  }\n\n  return Object.entries(routes).map(([path, value]) => normalizeMapEntry(path, value));\n};\n\n// Public: prepare routes by attaching a matcher to each entry.\nexport const prepare = (routes: RoutesInput = []): PreparedRoute[] => {\n  const list = toList(routes);\n\n  return list.map((r) => {\n    // Catch-all\n    if (r.path === \"*\" || r.path === \"/*\") {\n      return { ...r, matcher: () => ({ params: {} }) };\n    }\n\n    const { regex, names } = compilePath(r.path);\n    const matcher = (pathname: string): { params: Record<string, string> } | null => {\n      const m = regex.exec(pathname);\n      if (!m) return null;\n\n      const params = names.reduce<Record<string, string>>((acc, name, i) => {\n        acc[name] = decodeParam(m[i + 1]);\n        return acc;\n      }, {});\n\n      return { params };\n    };\n\n    return { ...r, matcher };\n  });\n};\n\n// Internal: find a match in a prepared list\nconst matchOne = (preparedRoutes: PreparedRoute[], pathname: string): RouteMatchResult => {\n  for (const r of preparedRoutes) {\n    if (typeof r.matcher !== \"function\") continue;\n    const res = r.matcher(pathname);\n    if (res) {\n      return {\n        Component: r.Component,\n        params: res.params || {},\n        reducerKey: r.reducerKey,\n      };\n    }\n  }\n\n  // Catch-all fallback if provided\n  const star = preparedRoutes.find((r) => r.path === \"*\" || r.path === \"/*\");\n  if (star) {\n    return {\n      Component: star.Component,\n      params: {},\n      reducerKey: star.reducerKey,\n    };\n  }\n\n  // Generic 404 fallback\n  return { Component: Generic404, params: {} };\n};\n\n// Public: match() accepts either raw routes or an already-prepared list\nexport const match = (\n  routes: RoutesInput | PreparedRoute[],\n  pathname: string,\n): RouteMatchResult => {\n  const prepared = isPreparedRouteArray(routes) ? routes : prepare(routes);\n  return matchOne(prepared, pathname);\n};\n\nexport default { prepare, match };\n", "import type { BrowserHistory, Update } from \"history\";\nimport { getScrollFromSessionStorage, type ScrollPosition } from \"./scroll\";\n\nexport interface ProgressAPI {\n  start(): void;\n  done(): void;\n}\n\nexport interface HandleHistoryChangeOptions {\n  history?: BrowserHistory | null;\n  fetchImpl?: ((url: string, init?: RequestInit) => Promise<Response>) | null;\n  setTitle?: (title: string) => void;\n  progress?: ProgressAPI;\n}\n\nconst makeUuid = (): string => {\n  // Browser / Workers\n  if (typeof globalThis !== \"undefined\" && globalThis.crypto) {\n    if (typeof globalThis.crypto.randomUUID === \"function\") {\n      return globalThis.crypto.randomUUID();\n    }\n    // RFC4122 v4 via getRandomValues\n    const buf = new Uint8Array(16);\n    globalThis.crypto.getRandomValues(buf);\n    buf[6] = (buf[6] & 0x0f) | 0x40;\n    buf[8] = (buf[8] & 0x3f) | 0x80;\n    const hex = [...buf].map((b) => b.toString(16).padStart(2, \"0\"));\n    return `${hex.slice(0, 4).join(\"\")}-${hex.slice(4, 6).join(\"\")}-${hex\n      .slice(6, 8)\n      .join(\"\")}-${hex.slice(8, 10).join(\"\")}-${hex.slice(10).join(\"\")}`;\n  }\n  // Node\n  try {\n    const { randomUUID } = (globalThis as any).require(\"node:crypto\");\n    if (typeof randomUUID === \"function\") return randomUUID();\n  } catch {}\n  // Last-resort (non-crypto)\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nconst INSTALLED = Symbol.for(\"handleHistoryChange:installed\");\nlet _inFlight: AbortController | null = null;\nlet _latestRequestId: number = 0;\nlet _scrollRestoreTimeout: ReturnType<typeof setTimeout> | null = null;\n\nconst clearScrollRestoreTimeout = (): void => {\n  if (_scrollRestoreTimeout) {\n    clearTimeout(_scrollRestoreTimeout);\n    _scrollRestoreTimeout = null;\n  }\n};\n\nconst originOf = (): string => {\n  try {\n    if (\n      typeof window !== \"undefined\" &&\n      window.location &&\n      window.location.origin\n    ) {\n      return window.location.origin;\n    }\n  } catch {}\n  return \"http://localhost\";\n};\n\nconst buildUrl = (loc: { pathname?: string; search?: string }): string => {\n  const url = new URL((loc.pathname || \"/\") + (loc.search || \"\"), originOf());\n  url.searchParams.set(\"uuid\", makeUuid());\n  return url.toString();\n};\n\nconst kindFrom = (status: number): \"ok\" | \"404\" | \"5xx\" => {\n  if (status === 404) return \"404\";\n  if (Math.floor(status / 100) === 5) return \"5xx\";\n  return \"ok\";\n};\n\nexport default function handleHistoryChange(\n  dispatch: (action: { type: string; data: Record<string, unknown> }) => void,\n  {\n    history,\n    fetchImpl = (typeof fetch !== \"undefined\" && fetch) || null,\n    setTitle = function (t: string): void {\n      if (typeof document !== \"undefined\" && t) document.title = t;\n    },\n    progress = { start() {}, done() {} }, // optional in tests\n  }: HandleHistoryChangeOptions = {},\n): () => void {\n  if (!history || !fetchImpl) {\n    return () => {};\n  }\n\n  if ((history as any)[INSTALLED]) {\n    return () => {};\n  }\n  (history as any)[INSTALLED] = true;\n\n  const unlisten = history.listen(function ({ location, action }: Update): void {\n    // Abort prior request\n    if (_inFlight && typeof _inFlight.abort === \"function\") {\n      try {\n        _inFlight.abort();\n      } catch {}\n    }\n    clearScrollRestoreTimeout();\n    const requestId = ++_latestRequestId;\n    _inFlight =\n      typeof AbortController !== \"undefined\" ? new AbortController() : null;\n\n    if (progress && typeof progress.done === \"function\") progress.done();\n    if (progress && typeof progress.start === \"function\") progress.start();\n\n    const url = buildUrl(location);\n\n    // Single promise chain so one microtask drain should be enough in tests\n    Promise.resolve(\n      fetchImpl(url, {\n        method: \"GET\",\n        headers: { Accept: \"application/json\" },\n        signal: _inFlight ? _inFlight.signal : undefined,\n      }),\n    )\n      .then(function (res): Promise<{ status: number; data: Record<string, unknown> }> {\n        const jp = res && res.json ? res.json() : {};\n        return Promise.resolve(jp)\n          .then(function (data) {\n            return { status: res ? res.status : 503, data: (data as Record<string, unknown>) || {} };\n          })\n          .catch(function () {\n            return { status: res ? res.status : 503, data: {} };\n          });\n      })\n      .catch(function () {\n        return { status: 503, data: {} };\n      })\n      .then(function ({ status, data }): void {\n        if (requestId !== _latestRequestId) return;\n        if (progress && typeof progress.done === \"function\") progress.done();\n\n        // Authorization redirect wins\n        const authLoc = (data as { authorization?: { location?: string } }).authorization\n          ?.location;\n        let finalLoc = authLoc || location.pathname || \"/\";\n\n        // Map 404/5xx if no explicit auth redirect\n        if (!authLoc) {\n          const k = kindFrom(status);\n          if (k === \"404\") finalLoc = \"/404\";\n          else if (k === \"5xx\") finalLoc = \"/500\";\n        }\n\n        dispatch({\n          type: \"CHANGE_PAGE\",\n          data: Object.assign({}, data, { location: finalLoc }),\n        });\n\n        // Title from top-level data.title\n        const title = (data as { title?: string }).title;\n        if (title) {\n          // eslint-disable-next-line no-console\n          setTitle(title);\n        }\n\n        // Scroll behavior: top on PUSH; restore for POP/REPLACE\n        if (typeof window !== \"undefined\" && window.scrollTo) {\n          if (action === \"PUSH\") {\n            window.scrollTo(0, 0);\n          } else {\n            const key = (location.pathname || \"/\") + (location.search || \"\");\n            const prev: ScrollPosition | null = getScrollFromSessionStorage(key);\n            if (prev) {\n              _scrollRestoreTimeout = setTimeout(function () {\n                window.scrollTo(prev.x || 0, prev.y || 0);\n                _scrollRestoreTimeout = null;\n              }, 250);\n            }\n          }\n        }\n      });\n  });\n\n  return (): void => {\n    if (typeof unlisten === \"function\") unlisten();\n    clearScrollRestoreTimeout();\n    if (_inFlight && typeof _inFlight.abort === \"function\") {\n      try {\n        _inFlight.abort();\n      } catch {}\n    }\n    _inFlight = null;\n    (history as any)[INSTALLED] = false;\n  };\n}\n\n// Test helpers (reset does nothing now because the guard is per-history instance)\nexport const __test__: {\n  reset: () => void;\n  state: () => { inFlight: boolean };\n} = {\n  reset: function (): void {\n    _latestRequestId = 0;\n    _inFlight = null;\n    clearScrollRestoreTimeout();\n  },\n  state: function (): { inFlight: boolean } {\n    return {\n      inFlight: !!_inFlight,\n    };\n  },\n};\n", "import React from \"react\";\nimport { Link } from \"../src/index.ts\";\n\nexport const Home = (props: {}) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>Home</h1>\n      <p>This is a tiny demo using the modernized router.</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/42\">User 42</Link>\n        <Link to=\"/about/dogs/hounds/buster\">About Buster</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nexport const About = (props: {}) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>About</h1>\n      <p>Try navigating with modifier keys to open in a new tab.</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/123\">User 123</Link>\n        <Link to=\"/about/dogs/hounds/buster\">About Buster</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nexport const AboutDogs = ({ params }: { params: string }) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>About Dogs</h1>\n      <p>Params: {params}</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/123\">User 123</Link>\n      </nav>\n    </div>\n  );\n};\n\nexport const User = ({ id }: { id: string }) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>User</h1>\n      <p>\n        User ID: <strong>{id}</strong>\n      </p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n      </nav>\n    </div>\n  );\n};\n\nconst routesMap = {\n  \"/\": Home,\n  \"/about\": About,\n  \"/users/:id\": User,\n  \"/about/dogs/:params+\": AboutDogs,\n};\n\nexport default routesMap;\n", "export const initialState = {\n  location: \"/\",\n  title: \"Demo\",\n  pageData: {}\n};\n\nexport default function reducer(state, action) {\n  switch (action.type) {\n    case \"LOCATION_CHANGED\": {\n      return { ...state, location: action.location };\n    }\n    case \"CHANGE_PAGE\": {\n      const next = { ...state, ...action.data };\n      // ensure location is in state for components\n      if (action.data && action.data.location) {\n        next.location = action.data.location;\n      }\n      return next;\n    }\n    default:\n      return state;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Action", "window", "location", "index", "action", "appHistory", "location", "jsx", "jsx"]
}
