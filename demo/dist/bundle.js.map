{
  "version": 3,
  "sources": ["../app.js", "../mockFetch.js", "../../src/router.js", "../../node_modules/@babel/runtime/helpers/esm/extends.js", "../../node_modules/history/index.js", "../../src/history.js", "../../src/helper.js", "../routes.js", "../reducer.js"],
  "sourcesContent": ["import React, { createContext, useReducer } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\n// \u2B07\uFE0F mock backend\nimport { installMockFetch } from \"./mockFetch.js\";\ninstallMockFetch();\n\nimport { createRouter } from \"../src/index.js\";\nimport routesMap from \"./routes.js\";\nimport reducer, { initialState } from \"./reducer.js\";\n\n// --- Store is REQUIRED ---\nexport const StateContext = createContext(null);\n\nconst StateProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <StateContext.Provider value={{ state, dispatch }}>\n      {children}\n    </StateContext.Provider>\n  );\n};\n\n// Router now takes (routes, storeContext)\nconst AppRouter = createRouter(routesMap, StateContext);\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(\n  <StateProvider>\n    <AppRouter />\n  </StateProvider>\n);\n", "// mockFetch.js\nexport function installMockFetch({ latency = 120 } = {}) {\n  // simple in-memory routes\n  const staticPages = {\n    \"/\": { title: \"Home\", pageData: { blurb: \"Welcome to the demo.\" } },\n    \"/about\": {\n      title: \"About\",\n      pageData: { blurb: \"This is a mock backend.\" },\n    },\n  };\n  const userRoute = /^\\/users\\/([^/]+)$/;\n\n  globalThis.fetch = async (reqUrl) => {\n    const u = new URL(reqUrl, location.origin);\n    const path = u.pathname; // ignore the ?uuid param we add\n    let status = 200;\n    let data = staticPages[path];\n\n    if (!data) {\n      const m = path.match(userRoute);\n      if (m) {\n        const id = m[1];\n        data = { title: `User ${id}`, pageData: { id, role: \"tester\" } };\n      }\n    }\n    if (!data) {\n      status = 404;\n      data = { title: \"Not Found\", pageData: { path } };\n    }\n\n    // simulate network\n    await new Promise((r) => setTimeout(r, latency));\n\n    return {\n      status,\n      json: async () => data,\n    };\n  };\n}\n", "import React, { useContext, useEffect, useMemo, useRef, useState } from \"react\";\nimport history from \"./history.js\";\nimport helper from \"./helper.js\";\n\n/** Programmatic navigation helper */\nexport const navigate = (to, { replace = false, state } = {}) => {\n  if (replace) history.replace(to, state);\n  else history.push(to, state);\n};\n\n/** Tiny <Link> that routes via shared history without full page reloads. */\nexport const Link = ({ to, replace = false, state, onClick, ...rest }) => {\n  const handleClick = (e) => {\n    if (onClick) onClick(e);\n    if (\n      e.defaultPrevented ||\n      e.button !== 0 || // left click\n      e.metaKey ||\n      e.altKey ||\n      e.ctrlKey ||\n      e.shiftKey\n    ) {\n      return;\n    }\n    e.preventDefault();\n    if (replace) history.replace(to, state);\n    else history.push(to, state);\n  };\n  return (\n    <a\n      href={typeof to === \"string\" ? to : to?.pathname || \"#\"}\n      onClick={handleClick}\n      {...rest}\n    />\n  );\n};\n\n/**\n * createRouter(routes, storeContext?) => <Router />\n *\n * - If a store context is provided, the router will use {state, dispatch} from it.\n * - If no store context is provided, props are treated as state and dispatch=false.\n * - Assumes initial store already has the current location; DOES NOT dispatch on mount.\n * - Listens to history and dispatches LOCATION_CHANGED only when location truly changes.\n */\nexport const createRouter = (routes, storeContext) => (props) => {\n  const appState = storeContext\n    ? useContext(storeContext)\n    : { state: props, dispatch: false };\n\n  const { state, dispatch } = appState || {};\n\n  // Prepare routes with regex matchers\n  const preparedRoutes = useMemo(() => helper.prepare(routes), [routes]);\n\n  const currentFromHistory =\n    (history?.location?.pathname || \"\") + (history?.location?.search || \"\");\n\n  const initialLocation = (state && state.location) || currentFromHistory;\n\n  // Track last known full location string (path + search)\n  const lastLocRef = useRef(initialLocation);\n\n  // Keep local state so the component re-renders on navigation\n  const [loc, setLoc] = useState(initialLocation);\n\n  useEffect(() => {\n    if (!history || typeof history.listen !== \"function\") return;\n\n    const unlisten = history.listen(({ location, action }) => {\n      const nextLoc = (location.pathname || \"\") + (location.search || \"\");\n      if (nextLoc !== lastLocRef.current) {\n        lastLocRef.current = nextLoc;\n        setLoc(nextLoc); // trigger re-render\n        if (typeof dispatch === \"function\") {\n          dispatch({\n            type: \"LOCATION_CHANGED\",\n            location: nextLoc,\n            meta: { action },\n          });\n        }\n      }\n    });\n\n    return () => {\n      if (typeof unlisten === \"function\") unlisten();\n    };\n  }, [dispatch]);\n\n  const activePathname = (loc || \"\").split(\"?\")[0];\n\n  // Use helper.match instead of the broken matchRoute function\n  const matched = useMemo(\n    () => helper.match(preparedRoutes, activePathname),\n    [preparedRoutes, activePathname]\n  );\n\n  const Component = matched?.Component || (() => null);\n  return <Component {...state} {...matched.params} dispatch={dispatch} />;\n};\n\nexport default createRouter;\n", "export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}", "import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "// Modernized history singleton with test-friendly exports (ESM)\nimport { createBrowserHistory, createMemoryHistory } from \"history\";\n\nexport const appHistory =\n  typeof window !== \"undefined\" && window.document && window.document.createElement\n    ? createBrowserHistory()\n    : null;\n\nexport const makeMemoryHistory = (initialEntries = [\"/\"]) =>\n  createMemoryHistory({ initialEntries });\n\nexport default appHistory;\n", "// src/helper.js\n// Route preparation & matching utility for Universal Route.\n// Accepts either an array of route objects OR a map of { \"/path\": Component | [Component, reducerKey] }.\n\nconst escapeRegex = (s) => s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\n// Compile a path pattern like \"/users/:id\" into a RegExp with named groups.\n// Supports \"*\" or \"/*\" catch-all.\nconst compilePath = (path) => {\n  if (!path || path === \"/\") {\n    return { regex: /^\\/?$/, names: [] };\n  }\n  if (path === \"*\" || path === \"/*\") {\n    return { regex: /^.*$/, names: [] };\n  }\n\n  const parts = String(path)\n    .split(\"/\")\n    .filter(Boolean)\n    .map((part) => {\n      if (part.startsWith(\":\")) {\n        const name = part.slice(1);\n        return { src: `(?<${name}>[^/]+)`, name };\n      }\n      return { src: escapeRegex(part), name: null };\n    });\n\n  const pattern = \"^/\" + parts.map((p) => p.src).join(\"/\") + \"/?$\";\n  const names = parts.filter((p) => p.name).map((p) => p.name);\n  return { regex: new RegExp(pattern), names };\n};\n\n// Graceful 404 Component that renders the text \"404\" (no React import required)\nconst Generic404 = () => \"404\";\n\n// Normalize a single map entry: (path, value) -> { path, Component, reducerKey }\nconst normalizeMapEntry = (path, value) => {\n  let Component, reducerKey;\n\n  if (Array.isArray(value)) {\n    [Component, reducerKey] = value;\n  } else if (typeof value === \"function\") {\n    Component = value;\n  } else if (value && typeof value === \"object\") {\n    // Allow object form { Component, element, render, reducerKey }\n    Component =\n      value.Component || value.element || value.render || (() => null);\n    reducerKey = value.reducerKey;\n  } else {\n    Component = () => null;\n  }\n\n  return { path, Component, reducerKey };\n};\n\n// Normalize a route object from array form: { path, Component | element | render, reducerKey? }\nconst normalizeArrayEntry = (routeObj = {}) => {\n  const { path = \"/\", reducerKey } = routeObj;\n  const Component =\n    routeObj.Component || routeObj.element || routeObj.render || (() => null);\n  return { path, Component, reducerKey };\n};\n\n// Convert routes (array or map) into a uniform list of { path, Component, reducerKey }\nconst toList = (routes) => {\n  if (Array.isArray(routes)) {\n    return routes.map(normalizeArrayEntry);\n  }\n  if (routes && typeof routes === \"object\") {\n    return Object.entries(routes).map(([path, value]) =>\n      normalizeMapEntry(path, value)\n    );\n  }\n  throw new TypeError(\n    \"routes must be an array of route objects or a map of { path: Component | [Component, reducerKey] }\"\n  );\n};\n\n// Public: prepare routes by attaching a matcher to each entry.\nexport const prepare = (routes = []) => {\n  const list = toList(routes);\n\n  return list.map((r) => {\n    // Catch-all\n    if (r.path === \"*\" || r.path === \"/*\") {\n      return { ...r, matcher: () => ({ params: {} }) };\n    }\n\n    const { regex, names } = compilePath(r.path);\n    const matcher = (pathname) => {\n      const m = regex.exec(pathname);\n      if (!m) return null;\n\n      const params = m.groups\n        ? Object.fromEntries(\n            Object.entries(m.groups).map(([k, v]) => [k, decodeURIComponent(v)])\n          )\n        : names.reduce((acc, name, i) => {\n            acc[name] = decodeURIComponent(m[i + 1]);\n            return acc;\n          }, {});\n\n      return { params };\n    };\n\n    return { ...r, matcher };\n  });\n};\n\n// Internal: find a match in a prepared list\nconst matchOne = (preparedRoutes, pathname) => {\n  for (const r of preparedRoutes) {\n    if (typeof r.matcher !== \"function\") continue;\n    const res = r.matcher(pathname);\n    if (res) {\n      return {\n        Component: r.Component,\n        params: res.params || {},\n        reducerKey: r.reducerKey,\n      };\n    }\n  }\n\n  // Catch-all fallback if provided\n  const star = preparedRoutes.find((r) => r.path === \"*\" || r.path === \"/*\");\n  if (star) {\n    return {\n      Component: star.Component,\n      params: {},\n      reducerKey: star.reducerKey,\n    };\n  }\n\n  // Generic 404 fallback\n  return { Component: Generic404, params: {} };\n};\n\n// Public: match() accepts either raw routes or an already-prepared list\nexport const match = (routesOrPrepared, pathname) => {\n  const isPreparedArray =\n    Array.isArray(routesOrPrepared) &&\n    routesOrPrepared.every(\n      (r) => typeof r === \"object\" && typeof r.matcher === \"function\"\n    );\n\n  const prepared = isPreparedArray\n    ? routesOrPrepared\n    : prepare(routesOrPrepared);\n  return matchOne(prepared, pathname);\n};\n\nexport default { prepare, match };\n", "import React from \"react\";\nimport { Link } from \"../src/index.js\";\n\nexport const Home = (props) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>Home</h1>\n      <p>This is a tiny demo using the modernized router.</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/42\">User 42</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nexport const About = (props) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>About</h1>\n      <p>Try navigating with modifier keys to open in a new tab.</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/123\">User 123</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nexport const User = ({ id }) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>User</h1>\n      <p>\n        User ID: <strong>{id}</strong>\n      </p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n      </nav>\n    </div>\n  );\n};\n\nconst routesMap = {\n  \"/\": Home,\n  \"/about\": About,\n  \"/users/:id\": User,\n};\n\nexport default routesMap;\n", "export const initialState = {\n  location: \"/\",\n  title: \"Demo\",\n  pageData: {}\n};\n\nexport default function reducer(state, action) {\n  switch (action.type) {\n    case \"LOCATION_CHANGED\": {\n      return { ...state, location: action.location };\n    }\n    case \"CHANGE_PAGE\": {\n      const next = { ...state, ...action.data };\n      // ensure location is in state for components\n      if (action.data && action.data.location) {\n        next.location = action.data.location;\n      }\n      return next;\n    }\n    default:\n      return state;\n  }\n}\n"],
  "mappings": "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",
  "names": ["React", "Action", "window", "location", "index", "action", "location", "React", "React", "React"]
}
