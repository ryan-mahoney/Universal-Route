{
  "version": 3,
  "sources": ["../app.js", "../mockFetch.js", "../../src/router.js", "../../node_modules/@babel/runtime/helpers/esm/extends.js", "../../node_modules/history/index.js", "../../src/history.js", "../../src/scroll.js", "../../src/helper.js", "../../src/pathToRegex.js", "../../src/handleHistoryChange.js", "../routes.js", "../reducer.js"],
  "sourcesContent": ["import React, { createContext, useReducer } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\n// \u2B07\uFE0F mock backend\nimport { installMockFetch } from \"./mockFetch.js\";\ninstallMockFetch();\n\nimport { createRouter } from \"../src/index.js\";\nimport routesMap from \"./routes.js\";\nimport reducer, { initialState } from \"./reducer.js\";\n\n// --- Store is REQUIRED ---\nexport const StateContext = createContext(null);\n\nconst StateProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <StateContext.Provider value={{ state, dispatch }}>\n      {children}\n    </StateContext.Provider>\n  );\n};\n\n// Router now takes (routes, storeContext)\nconst AppRouter = createRouter(routesMap, StateContext);\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(\n  <StateProvider>\n    <AppRouter />\n  </StateProvider>\n);\n", "// mockFetch.js\nexport function installMockFetch({ latency = 120 } = {}) {\n  // simple in-memory routes\n  const staticPages = {\n    \"/\": { title: \"Home\", pageData: { blurb: \"Welcome to the demo.\" } },\n    \"/about\": {\n      title: \"About\",\n      pageData: { blurb: \"This is a mock backend.\" },\n    },\n  };\n  const userRoute = /^\\/users\\/([^/]+)$/;\n\n  globalThis.fetch = async (reqUrl) => {\n    const u = new URL(reqUrl, location.origin);\n    const path = u.pathname; // ignore the ?uuid param we add\n    let status = 200;\n    let data = staticPages[path];\n\n    if (!data) {\n      const m = path.match(userRoute);\n      if (m) {\n        const id = m[1];\n        data = { title: `User ${id}`, pageData: { id, role: \"tester\" } };\n      }\n    }\n    if (!data) {\n      status = 404;\n      data = { title: \"Not Found\", pageData: { path } };\n    }\n\n    // simulate network\n    await new Promise((r) => setTimeout(r, latency));\n\n    return {\n      status,\n      json: async () => data,\n    };\n  };\n}\n", "import React from \"react\";\nimport appHistory from \"./history.js\";\nimport { setScrollToSessionStorage } from \"./scroll.js\";\nimport helper from \"./helper.js\";\nimport handleHistoryChange from \"./handleHistoryChange.js\";\n\nlet handleSyncRegistered = false;\n\nexport const Link = ({\n  to,\n  className,\n  children,\n  mode = \"push\",\n  onMouseEnter,\n  onMouseLeave,\n  style = {},\n  ...rest\n}) => {\n  const onClick = (e) => {\n    if (\n      e.defaultPrevented ||\n      e.button !== 0 ||\n      e.metaKey ||\n      e.ctrlKey ||\n      e.altKey ||\n      e.shiftKey\n    ) {\n      return;\n    }\n    e.preventDefault();\n    setScrollToSessionStorage();\n    if (!appHistory) return;\n    if (mode === \"replace\") {\n      appHistory.replace(to);\n    } else {\n      appHistory.push(to);\n    }\n  };\n\n  return (\n    <a\n      href={to}\n      className={className}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={style}\n      {...rest}\n    >\n      {children}\n    </a>\n  );\n};\n\nexport const navigate = (to, mode = \"push\") => {\n  if (!appHistory) return;\n  if (mode === \"replace\") appHistory.replace(to);\n  else appHistory.push(to);\n};\n\n/**\n * API: createRouter(routes, storeContext) => RouterComponent\n * A store is REQUIRED. There is no store-less mode.\n */\nexport const createRouter = (routes, store) => {\n  if (!store) {\n    throw new Error(\n      \"createRouter(routes, store): a store/context is required. Wrap your app with a Provider that supplies {state, dispatch}.\"\n    );\n  }\n\n  const Router = () => {\n    // Prepare routes once\n    const preparedRoutesRef = React.useRef(null);\n    if (!preparedRoutesRef.current) {\n      preparedRoutesRef.current = helper.prepare(routes);\n    }\n\n    // Pull state/dispatch from required store\n    const appState = React.useContext(store);\n    if (\n      !appState ||\n      typeof appState !== \"object\" ||\n      !(\"state\" in appState) ||\n      typeof appState.dispatch !== \"function\"\n    ) {\n      throw new Error(\n        \"Router: expected context value {state, dispatch}. Ensure your <StateProvider> supplies both.\"\n      );\n    }\n\n    const { state, dispatch } = appState;\n\n    // Sync history -> store\n    React.useEffect(() => {\n      if (!dispatch || !appHistory) return;\n\n      const unlisten = appHistory.listen(({ location }) => {\n        const nextLoc = location.pathname + (location.search || \"\");\n        dispatch({ type: \"LOCATION_CHANGED\", location: nextLoc });\n      });\n\n      // initial sync (hydrate if state.location is missing or stale)\n      dispatch({\n        type: \"LOCATION_CHANGED\",\n        location:\n          appHistory.location.pathname + (appHistory.location.search || \"\"),\n      });\n\n      return () => unlisten();\n    }, [dispatch]);\n\n    // Register network/side-effect sync once (per app shell)\n    React.useEffect(() => {\n      if (!handleSyncRegistered && dispatch) {\n        handleHistoryChange(dispatch);\n        handleSyncRegistered = true;\n      }\n    }, [dispatch]);\n\n    // Location is sourced ONLY from store\n    const currentLocation = state.location || \"/\";\n    const pathOnly = currentLocation.split(\"?\", 1)[0];\n\n    const { Component, params } = helper.match(\n      preparedRoutesRef.current,\n      pathOnly\n    );\n\n    return <Component {...state} params={params} dispatch={dispatch} />;\n  };\n\n  return Router;\n};\n\nexport default { Link, navigate, createRouter };\n", "export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}", "import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "// Modernized history singleton with test-friendly exports (ESM)\nimport { createBrowserHistory, createMemoryHistory } from \"history\";\n\nexport const appHistory =\n  typeof window !== \"undefined\" && window.document && window.document.createElement\n    ? createBrowserHistory()\n    : null;\n\nexport const makeMemoryHistory = (initialEntries = [\"/\"]) =>\n  createMemoryHistory({ initialEntries });\n\nexport default appHistory;\n", "// Centralized scroll helpers with query-aware keys\nconst SCROLL_KEY = \"scroll\";\n\nexport const getScrollPosition = () => ({\n  y: window.pageYOffset || document.documentElement.scrollTop || 0,\n  x: window.pageXOffset || document.documentElement.scrollLeft || 0\n});\n\nconst currentKey = () => {\n  const { pathname, search } = window.location;\n  return `${pathname}${search || \"\"}`;\n};\n\nconst readStore = () => {\n  if (typeof sessionStorage === \"undefined\") return {};\n  try {\n    const blob = sessionStorage.getItem(SCROLL_KEY);\n    return blob ? JSON.parse(blob) : {};\n  } catch {\n    return {};\n  }\n};\n\nconst writeStore = (obj) => {\n  if (typeof sessionStorage === \"undefined\") return;\n  try {\n    sessionStorage.setItem(SCROLL_KEY, JSON.stringify(obj));\n  } catch {\n    /* ignore quota/security errors */\n  }\n};\n\nexport const setScrollToSessionStorage = () => {\n  const store = readStore();\n  store[currentKey()] = getScrollPosition();\n  writeStore(store);\n};\n\nexport const setScrollForKey = (key, pos) => {\n  const store = readStore();\n  store[key] = pos || getScrollPosition();\n  writeStore(store);\n};\n\nexport const getScrollFromSessionStorage = (key = \"*\") => {\n  const store = readStore();\n  if (key === \"*\") return store;\n  return store[key] || null;\n};\n", "import React from \"react\";\nimport { match } from \"./pathToRegex.js\";\n\nconst Generic404 = () => (\n  <div style={{ padding: 24 }}>\n    <h1>404</h1>\n    <p>Page not found</p>\n  </div>\n);\n\nconst matchOne = (preparedRoutes, location) => {\n  for (const r of preparedRoutes) {\n    const res = r.matcher(location);\n    if (res) {\n      return { route: r, params: res.params || {} };\n    }\n  }\n  return null;\n};\n\nexport default {\n  match: (preparedRoutes, location) => {\n    const m = matchOne(preparedRoutes, location);\n    if (!m) return { Component: Generic404, reducerKey: null, params: {} };\n    const { route, params } = m;\n    const { Component, reducerKey } = route;\n    return { Component, reducerKey, params };\n  },\n  prepare: (routesMap) =>\n    Object.keys(routesMap).map((path) => {\n      const defn = routesMap[path];\n      let component, reducerKey;\n      if (Array.isArray(defn)) {\n        [component, reducerKey] = defn;\n      } else {\n        component = defn;\n      }\n      return {\n        path,\n        matcher: match(path, { decode: decodeURIComponent }),\n        Component: component,\n        reducerKey: reducerKey || null,\n      };\n    }),\n};\n", "/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n  const tokens = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options = {}) {\n  const tokens = lexer(str);\n  const { prefixes = \"./\", delimiter = \"/#?\" } = options;\n  const result = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type) => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type) => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = () => {\n    let result = \"\";\n    let value;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const isSafe = (value) => {\n    for (const char of delimiter) if (value.indexOf(char) > -1) return true;\n    return false;\n  };\n\n  const safePattern = (prefix) => {\n    const prev = result[result.length - 1];\n    const prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n\n    if (prev && !prevText) {\n      throw new TypeError(\n        `Must have text between two parameters, missing text after \"${prev.name}\"`\n      );\n    }\n\n    if (!prevText || isSafe(prevText)) return `[^${escapeString(delimiter)}]+?`;\n    return `(?:(?!${escapeString(prevText)})[^${escapeString(delimiter)}])+?`;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || safePattern(prefix),\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? safePattern(prefix) : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options = {}) {\n  const reFlags = flags(options);\n  const { encode = (x) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n  const keys = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options = {}) {\n  const { decode = (x) => x } = options;\n\n  return function (pathname) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options = {}) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            throw new TypeError(\n              `Can not repeat \"${token.name}\" without a prefix and suffix`\n            );\n          }\n\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import { getScrollFromSessionStorage } from \"./scroll.js\";\n\nconst makeUuid = () => {\n  // Browser / Workers\n  if (typeof globalThis !== \"undefined\" && globalThis.crypto) {\n    if (typeof globalThis.crypto.randomUUID === \"function\") {\n      return globalThis.crypto.randomUUID();\n    }\n    // RFC4122 v4 via getRandomValues\n    const buf = new Uint8Array(16);\n    globalThis.crypto.getRandomValues(buf);\n    buf[6] = (buf[6] & 0x0f) | 0x40;\n    buf[8] = (buf[8] & 0x3f) | 0x80;\n    const hex = [...buf].map((b) => b.toString(16).padStart(2, \"0\"));\n    return `${hex.slice(0, 4).join(\"\")}-${hex.slice(4, 6).join(\"\")}-${hex\n      .slice(6, 8)\n      .join(\"\")}-${hex.slice(8, 10).join(\"\")}-${hex.slice(10).join(\"\")}`;\n  }\n  // Node\n  try {\n    const { randomUUID } = require(\"node:crypto\");\n    if (typeof randomUUID === \"function\") return randomUUID();\n  } catch {}\n  // Last-resort (non-crypto)\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nconst INSTALLED = Symbol.for(\"handleHistoryChange:installed\");\nlet _inFlight = null;\n\nfunction originOf() {\n  try {\n    if (\n      typeof window !== \"undefined\" &&\n      window.location &&\n      window.location.origin\n    ) {\n      return window.location.origin;\n    }\n  } catch (e) {}\n  return \"http://localhost\";\n}\n\nfunction buildUrl(loc) {\n  const url = new URL((loc.pathname || \"/\") + (loc.search || \"\"), originOf());\n  url.searchParams.set(\"uuid\", makeUuid());\n  return url.toString();\n}\n\nfunction kindFrom(status) {\n  if (status === 404) return \"404\";\n  if (Math.floor(status / 100) === 5) return \"5xx\";\n  return \"ok\";\n}\n\nexport default function handleHistoryChange(\n  dispatch,\n  {\n    history,\n    fetchImpl = (typeof fetch !== \"undefined\" && fetch) || null,\n    setTitle = function (t) {\n      if (typeof document !== \"undefined\" && t) document.title = t;\n    },\n    progress = { start() {}, done() {} }, // optional in tests\n  } = {}\n) {\n  if (!history || !fetchImpl) {\n    return;\n  }\n\n  if (history[INSTALLED]) {\n    return;\n  }\n  history[INSTALLED] = true;\n\n  history.listen(function ({ location, action }) {\n    // Abort prior request\n    if (_inFlight && typeof _inFlight.abort === \"function\") {\n      try {\n        _inFlight.abort();\n      } catch (e) {}\n    }\n    _inFlight =\n      typeof AbortController !== \"undefined\" ? new AbortController() : null;\n\n    if (progress && typeof progress.done === \"function\") progress.done();\n    if (progress && typeof progress.start === \"function\") progress.start();\n\n    const url = buildUrl(location);\n\n    // Single promise chain so one microtask drain should be enough in tests\n    Promise.resolve(\n      fetchImpl(url, {\n        method: \"GET\",\n        headers: { Accept: \"application/json\" },\n        signal: _inFlight ? _inFlight.signal : undefined,\n      })\n    )\n      .then(function (res) {\n        const jp = res && res.json ? res.json() : {};\n        return Promise.resolve(jp)\n          .then(function (data) {\n            return { status: res ? res.status : 503, data: data || {} };\n          })\n          .catch(function () {\n            return { status: res ? res.status : 503, data: {} };\n          });\n      })\n      .catch(function (err) {\n        return { status: 503, data: {} };\n      })\n      .then(function ({ status, data }) {\n        if (progress && typeof progress.done === \"function\") progress.done();\n\n        // Authorization redirect wins\n        const authLoc =\n          data && data.authorization && data.authorization.location;\n        let finalLoc = authLoc || location.pathname || \"/\";\n\n        // Map 404/5xx if no explicit auth redirect\n        if (!authLoc) {\n          const k = kindFrom(status);\n          if (k === \"404\") finalLoc = \"/404\";\n          else if (k === \"5xx\") finalLoc = \"/500\";\n        }\n\n        dispatch({\n          type: \"CHANGE_PAGE\",\n          data: Object.assign({}, data, { location: finalLoc }),\n        });\n\n        // Title from top-level data.title\n        if (data && data.title) {\n          // eslint-disable-next-line no-console\n          setTitle(data.title);\n        }\n\n        // Scroll behavior: top on PUSH; restore for POP/REPLACE\n        if (typeof window !== \"undefined\" && window.scrollTo) {\n          if (action === \"PUSH\") {\n            window.scrollTo(0, 0);\n          } else {\n            const key = (location.pathname || \"/\") + (location.search || \"\");\n            const prev = getScrollFromSessionStorage(key);\n            if (prev) {\n              setTimeout(function () {\n                window.scrollTo(prev.x || 0, prev.y || 0);\n              }, 250);\n            }\n          }\n        }\n      });\n  });\n}\n\n// Test helpers (reset does nothing now because the guard is per-history instance)\nexport const __test__ = {\n  reset: function () {},\n  state: function () {\n    return {\n      inFlight: !!_inFlight,\n    };\n  },\n};\n", "import React from \"react\";\nimport { Link } from \"../src/index.js\";\n\nexport const Home = (props) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>Home</h1>\n      <p>This is a tiny demo using the modernized router.</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/42\">User 42</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nexport const About = (props) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>About</h1>\n      <p>Try navigating with modifier keys to open in a new tab.</p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users/123\">User 123</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nexport const User = ({ params, ...props }) => {\n  return (\n    <div style={{ padding: 24 }}>\n      <h1>User</h1>\n      <p>\n        User ID: <strong>{params.id}</strong>\n      </p>\n      <nav style={{ display: \"flex\", gap: 12 }}>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n      </nav>\n      <pre style={{ background: \"#f6f8fa\", padding: 12, marginTop: 16 }}>\n        {JSON.stringify({ params, state: props }, null, 2)}\n      </pre>\n    </div>\n  );\n};\n\nconst routesMap = {\n  \"/\": Home,\n  \"/about\": About,\n  \"/users/:id\": User,\n};\n\nexport default routesMap;\n", "export const initialState = {\n  location: \"/\",\n  title: \"Demo\",\n  pageData: {}\n};\n\nexport default function reducer(state, action) {\n  switch (action.type) {\n    case \"LOCATION_CHANGED\": {\n      return { ...state, location: action.location };\n    }\n    case \"CHANGE_PAGE\": {\n      const next = { ...state, ...action.data };\n      // ensure location is in state for components\n      if (action.data && action.data.location) {\n        next.location = action.data.location;\n      }\n      return next;\n    }\n    default:\n      return state;\n  }\n}\n"],
  "mappings": ";;;;;;;;AAAA,OAAOA,UAAS,eAAe,kBAAkB;AACjD,SAAS,kBAAkB;;;ACApB,SAAS,iBAAiB,EAAE,UAAU,IAAI,IAAI,CAAC,GAAG;AAEvD,QAAM,cAAc;AAAA,IAClB,KAAK,EAAE,OAAO,QAAQ,UAAU,EAAE,OAAO,uBAAuB,EAAE;AAAA,IAClE,UAAU;AAAA,MACR,OAAO;AAAA,MACP,UAAU,EAAE,OAAO,0BAA0B;AAAA,IAC/C;AAAA,EACF;AACA,QAAM,YAAY;AAElB,aAAW,QAAQ,OAAO,WAAW;AACnC,UAAM,IAAI,IAAI,IAAI,QAAQ,SAAS,MAAM;AACzC,UAAM,OAAO,EAAE;AACf,QAAI,SAAS;AACb,QAAI,OAAO,YAAY,IAAI;AAE3B,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,KAAK,MAAM,SAAS;AAC9B,UAAI,GAAG;AACL,cAAM,KAAK,EAAE,CAAC;AACd,eAAO,EAAE,OAAO,QAAQ,EAAE,IAAI,UAAU,EAAE,IAAI,MAAM,SAAS,EAAE;AAAA,MACjE;AAAA,IACF;AACA,QAAI,CAAC,MAAM;AACT,eAAS;AACT,aAAO,EAAE,OAAO,aAAa,UAAU,EAAE,KAAK,EAAE;AAAA,IAClD;AAGA,UAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,OAAO,CAAC;AAE/C,WAAO;AAAA,MACL;AAAA,MACA,MAAM,YAAY;AAAA,IACpB;AAAA,EACF;AACF;;;ACtCA,OAAOC,YAAW;;;ACAH,SAAR,WAA4B;AACjC,aAAW,OAAO,UAAU,SAAU,QAAQ;AAC5C,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAI,SAAS,UAAU,CAAC;AAExB,eAAS,OAAO,QAAQ;AACtB,YAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,GAAG,GAAG;AACrD,iBAAO,GAAG,IAAI,OAAO,GAAG;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,SAAO,SAAS,MAAM,MAAM,SAAS;AACvC;;;ACTA,IAAI;AAAA,CAEH,SAAUC,SAAQ;AAQjB,EAAAA,QAAO,KAAK,IAAI;AAOhB,EAAAA,QAAO,MAAM,IAAI;AAMjB,EAAAA,QAAO,SAAS,IAAI;AACtB,GAAG,WAAW,SAAS,CAAC,EAAE;AAE1B,IAAI,WAAW,OAAwC,SAAU,KAAK;AACpE,SAAO,OAAO,OAAO,GAAG;AAC1B,IAAI,SAAU,KAAK;AACjB,SAAO;AACT;AAEA,SAAS,QAAQ,MAAM,SAAS;AAC9B,MAAI,CAAC,MAAM;AAET,QAAI,OAAO,YAAY,YAAa,SAAQ,KAAK,OAAO;AAExD,QAAI;AAMF,YAAM,IAAI,MAAM,OAAO;AAAA,IACzB,SAAS,GAAG;AAAA,IAAC;AAAA,EACf;AACF;AAEA,IAAI,wBAAwB;AAE5B,IAAI,oBAAoB;AASxB,SAAS,qBAAqB,SAAS;AACrC,MAAI,YAAY,QAAQ;AACtB,cAAU,CAAC;AAAA,EACb;AAEA,MAAI,WAAW,SACX,kBAAkB,SAAS,QAC3BC,UAAS,oBAAoB,SAAS,SAAS,cAAc;AACjE,MAAI,gBAAgBA,QAAO;AAE3B,WAAS,sBAAsB;AAC7B,QAAI,mBAAmBA,QAAO,UAC1B,WAAW,iBAAiB,UAC5B,SAAS,iBAAiB,QAC1B,OAAO,iBAAiB;AAC5B,QAAI,QAAQ,cAAc,SAAS,CAAC;AACpC,WAAO,CAAC,MAAM,KAAK,SAAS;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,MAAM,OAAO;AAAA,MACpB,KAAK,MAAM,OAAO;AAAA,IACpB,CAAC,CAAC;AAAA,EACJ;AAEA,MAAI,eAAe;AAEnB,WAAS,YAAY;AACnB,QAAI,cAAc;AAChB,eAAS,KAAK,YAAY;AAC1B,qBAAe;AAAA,IACjB,OAAO;AACL,UAAI,aAAa,OAAO;AAExB,UAAI,uBAAuB,oBAAoB,GAC3C,YAAY,qBAAqB,CAAC,GAClC,eAAe,qBAAqB,CAAC;AAEzC,UAAI,SAAS,QAAQ;AACnB,YAAI,aAAa,MAAM;AACrB,cAAI,QAAQ,QAAQ;AAEpB,cAAI,OAAO;AAET,2BAAe;AAAA,cACb,QAAQ;AAAA,cACR,UAAU;AAAA,cACV,OAAO,SAAS,QAAQ;AACtB,mBAAG,QAAQ,EAAE;AAAA,cACf;AAAA,YACF;AACA,eAAG,KAAK;AAAA,UACV;AAAA,QACF,OAAO;AAGL,iBAAwC;AAAA,YAAQ;AAAA;AAAA;AAAA;AAAA,YAGhD;AAAA,UAAwT,IAAI;AAAA,QAC9T;AAAA,MACF,OAAO;AACL,gBAAQ,UAAU;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAEA,EAAAA,QAAO,iBAAiB,mBAAmB,SAAS;AACpD,MAAI,SAAS,OAAO;AAEpB,MAAI,wBAAwB,oBAAoB,GAC5C,QAAQ,sBAAsB,CAAC,GAC/BC,YAAW,sBAAsB,CAAC;AAEtC,MAAI,YAAY,aAAa;AAC7B,MAAI,WAAW,aAAa;AAE5B,MAAI,SAAS,MAAM;AACjB,YAAQ;AACR,kBAAc,aAAa,SAAS,CAAC,GAAG,cAAc,OAAO;AAAA,MAC3D,KAAK;AAAA,IACP,CAAC,GAAG,EAAE;AAAA,EACR;AAEA,WAAS,WAAW,IAAI;AACtB,WAAO,OAAO,OAAO,WAAW,KAAK,WAAW,EAAE;AAAA,EACpD;AAGA,WAAS,gBAAgB,IAAI,OAAO;AAClC,QAAI,UAAU,QAAQ;AACpB,cAAQ;AAAA,IACV;AAEA,WAAO,SAAS,SAAS;AAAA,MACvB,UAAUA,UAAS;AAAA,MACnB,MAAM;AAAA,MACN,QAAQ;AAAA,IACV,GAAG,OAAO,OAAO,WAAW,UAAU,EAAE,IAAI,IAAI;AAAA,MAC9C;AAAA,MACA,KAAK,UAAU;AAAA,IACjB,CAAC,CAAC;AAAA,EACJ;AAEA,WAAS,sBAAsB,cAAcC,QAAO;AAClD,WAAO,CAAC;AAAA,MACN,KAAK,aAAa;AAAA,MAClB,KAAK,aAAa;AAAA,MAClB,KAAKA;AAAA,IACP,GAAG,WAAW,YAAY,CAAC;AAAA,EAC7B;AAEA,WAAS,QAAQC,SAAQF,WAAU,OAAO;AACxC,WAAO,CAAC,SAAS,WAAW,SAAS,KAAK;AAAA,MACxC,QAAQE;AAAA,MACR,UAAUF;AAAA,MACV;AAAA,IACF,CAAC,GAAG;AAAA,EACN;AAEA,WAAS,QAAQ,YAAY;AAC3B,aAAS;AAET,QAAI,wBAAwB,oBAAoB;AAEhD,YAAQ,sBAAsB,CAAC;AAC/B,IAAAA,YAAW,sBAAsB,CAAC;AAClC,cAAU,KAAK;AAAA,MACb;AAAA,MACA,UAAUA;AAAA,IACZ,CAAC;AAAA,EACH;AAEA,WAAS,KAAK,IAAI,OAAO;AACvB,QAAI,aAAa,OAAO;AACxB,QAAI,eAAe,gBAAgB,IAAI,KAAK;AAE5C,aAAS,QAAQ;AACf,WAAK,IAAI,KAAK;AAAA,IAChB;AAEA,QAAI,QAAQ,YAAY,cAAc,KAAK,GAAG;AAC5C,UAAI,wBAAwB,sBAAsB,cAAc,QAAQ,CAAC,GACrE,eAAe,sBAAsB,CAAC,GACtC,MAAM,sBAAsB,CAAC;AAIjC,UAAI;AACF,sBAAc,UAAU,cAAc,IAAI,GAAG;AAAA,MAC/C,SAAS,OAAO;AAGd,QAAAD,QAAO,SAAS,OAAO,GAAG;AAAA,MAC5B;AAEA,cAAQ,UAAU;AAAA,IACpB;AAAA,EACF;AAEA,WAAS,QAAQ,IAAI,OAAO;AAC1B,QAAI,aAAa,OAAO;AACxB,QAAI,eAAe,gBAAgB,IAAI,KAAK;AAE5C,aAAS,QAAQ;AACf,cAAQ,IAAI,KAAK;AAAA,IACnB;AAEA,QAAI,QAAQ,YAAY,cAAc,KAAK,GAAG;AAC5C,UAAI,yBAAyB,sBAAsB,cAAc,KAAK,GAClE,eAAe,uBAAuB,CAAC,GACvC,MAAM,uBAAuB,CAAC;AAGlC,oBAAc,aAAa,cAAc,IAAI,GAAG;AAChD,cAAQ,UAAU;AAAA,IACpB;AAAA,EACF;AAEA,WAAS,GAAG,OAAO;AACjB,kBAAc,GAAG,KAAK;AAAA,EACxB;AAEA,MAAI,UAAU;AAAA,IACZ,IAAI,SAAS;AACX,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,WAAW;AACb,aAAOC;AAAA,IACT;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,SAAS,OAAO;AACpB,SAAG,EAAE;AAAA,IACP;AAAA,IACA,SAAS,SAAS,UAAU;AAC1B,SAAG,CAAC;AAAA,IACN;AAAA,IACA,QAAQ,SAAS,OAAO,UAAU;AAChC,aAAO,UAAU,KAAK,QAAQ;AAAA,IAChC;AAAA,IACA,OAAO,SAAS,MAAM,SAAS;AAC7B,UAAI,UAAU,SAAS,KAAK,OAAO;AAEnC,UAAI,SAAS,WAAW,GAAG;AACzB,QAAAD,QAAO,iBAAiB,uBAAuB,kBAAkB;AAAA,MACnE;AAEA,aAAO,WAAY;AACjB,gBAAQ;AAIR,YAAI,CAAC,SAAS,QAAQ;AACpB,UAAAA,QAAO,oBAAoB,uBAAuB,kBAAkB;AAAA,QACtE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAsaA,SAAS,mBAAmB,OAAO;AAEjC,QAAM,eAAe;AAErB,QAAM,cAAc;AACtB;AAEA,SAAS,eAAe;AACtB,MAAI,WAAW,CAAC;AAChB,SAAO;AAAA,IACL,IAAI,SAAS;AACX,aAAO,SAAS;AAAA,IAClB;AAAA,IAEA,MAAM,SAAS,KAAK,IAAI;AACtB,eAAS,KAAK,EAAE;AAChB,aAAO,WAAY;AACjB,mBAAW,SAAS,OAAO,SAAU,SAAS;AAC5C,iBAAO,YAAY;AAAA,QACrB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,MAAM,SAAS,KAAK,KAAK;AACvB,eAAS,QAAQ,SAAU,IAAI;AAC7B,eAAO,MAAM,GAAG,GAAG;AAAA,MACrB,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAEA,SAAS,YAAY;AACnB,SAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC;AAC/C;AAQA,SAAS,WAAW,MAAM;AACxB,MAAI,gBAAgB,KAAK,UACrB,WAAW,kBAAkB,SAAS,MAAM,eAC5C,cAAc,KAAK,QACnB,SAAS,gBAAgB,SAAS,KAAK,aACvC,YAAY,KAAK,MACjB,OAAO,cAAc,SAAS,KAAK;AACvC,MAAI,UAAU,WAAW,IAAK,aAAY,OAAO,OAAO,CAAC,MAAM,MAAM,SAAS,MAAM;AACpF,MAAI,QAAQ,SAAS,IAAK,aAAY,KAAK,OAAO,CAAC,MAAM,MAAM,OAAO,MAAM;AAC5E,SAAO;AACT;AAOA,SAAS,UAAU,MAAM;AACvB,MAAI,aAAa,CAAC;AAElB,MAAI,MAAM;AACR,QAAI,YAAY,KAAK,QAAQ,GAAG;AAEhC,QAAI,aAAa,GAAG;AAClB,iBAAW,OAAO,KAAK,OAAO,SAAS;AACvC,aAAO,KAAK,OAAO,GAAG,SAAS;AAAA,IACjC;AAEA,QAAI,cAAc,KAAK,QAAQ,GAAG;AAElC,QAAI,eAAe,GAAG;AACpB,iBAAW,SAAS,KAAK,OAAO,WAAW;AAC3C,aAAO,KAAK,OAAO,GAAG,WAAW;AAAA,IACnC;AAEA,QAAI,MAAM;AACR,iBAAW,WAAW;AAAA,IACxB;AAAA,EACF;AAEA,SAAO;AACT;;;ACtxBO,IAAM,aACX,OAAO,WAAW,eAAe,OAAO,YAAY,OAAO,SAAS,gBAChE,qBAAqB,IACrB;AAKN,IAAO,kBAAQ;;;ACVf,IAAM,aAAa;AAEZ,IAAM,oBAAoB,OAAO;AAAA,EACtC,GAAG,OAAO,eAAe,SAAS,gBAAgB,aAAa;AAAA,EAC/D,GAAG,OAAO,eAAe,SAAS,gBAAgB,cAAc;AAClE;AAEA,IAAM,aAAa,MAAM;AACvB,QAAM,EAAE,UAAU,OAAO,IAAI,OAAO;AACpC,SAAO,GAAG,QAAQ,GAAG,UAAU,EAAE;AACnC;AAEA,IAAM,YAAY,MAAM;AACtB,MAAI,OAAO,mBAAmB,YAAa,QAAO,CAAC;AACnD,MAAI;AACF,UAAM,OAAO,eAAe,QAAQ,UAAU;AAC9C,WAAO,OAAO,KAAK,MAAM,IAAI,IAAI,CAAC;AAAA,EACpC,QAAQ;AACN,WAAO,CAAC;AAAA,EACV;AACF;AAEA,IAAM,aAAa,CAAC,QAAQ;AAC1B,MAAI,OAAO,mBAAmB,YAAa;AAC3C,MAAI;AACF,mBAAe,QAAQ,YAAY,KAAK,UAAU,GAAG,CAAC;AAAA,EACxD,QAAQ;AAAA,EAER;AACF;AAEO,IAAM,4BAA4B,MAAM;AAC7C,QAAM,QAAQ,UAAU;AACxB,QAAM,WAAW,CAAC,IAAI,kBAAkB;AACxC,aAAW,KAAK;AAClB;AAQO,IAAM,8BAA8B,CAAC,MAAM,QAAQ;AACxD,QAAM,QAAQ,UAAU;AACxB,MAAI,QAAQ,IAAK,QAAO;AACxB,SAAO,MAAM,GAAG,KAAK;AACvB;;;AChDA,OAAO,WAAW;;;ACGlB,SAAS,MAAM,KAAK;AAClB,QAAM,SAAS,CAAC;AAChB,MAAI,IAAI;AAER,SAAO,IAAI,IAAI,QAAQ;AACrB,UAAM,OAAO,IAAI,CAAC;AAElB,QAAI,SAAS,OAAO,SAAS,OAAO,SAAS,KAAK;AAChD,aAAO,KAAK,EAAE,MAAM,YAAY,OAAO,GAAG,OAAO,IAAI,GAAG,EAAE,CAAC;AAC3D;AAAA,IACF;AAEA,QAAI,SAAS,MAAM;AACjB,aAAO,KAAK,EAAE,MAAM,gBAAgB,OAAO,KAAK,OAAO,IAAI,GAAG,EAAE,CAAC;AACjE;AAAA,IACF;AAEA,QAAI,SAAS,KAAK;AAChB,aAAO,KAAK,EAAE,MAAM,QAAQ,OAAO,GAAG,OAAO,IAAI,GAAG,EAAE,CAAC;AACvD;AAAA,IACF;AAEA,QAAI,SAAS,KAAK;AAChB,aAAO,KAAK,EAAE,MAAM,SAAS,OAAO,GAAG,OAAO,IAAI,GAAG,EAAE,CAAC;AACxD;AAAA,IACF;AAEA,QAAI,SAAS,KAAK;AAChB,UAAI,OAAO;AACX,UAAI,IAAI,IAAI;AAEZ,aAAO,IAAI,IAAI,QAAQ;AACrB,cAAM,OAAO,IAAI,WAAW,CAAC;AAE7B;AAAA;AAAA,UAEG,QAAQ,MAAM,QAAQ;AAAA,UAEtB,QAAQ,MAAM,QAAQ;AAAA,UAEtB,QAAQ,MAAM,QAAQ;AAAA,UAEvB,SAAS;AAAA,UACT;AACA,kBAAQ,IAAI,GAAG;AACf;AAAA,QACF;AAEA;AAAA,MACF;AAEA,UAAI,CAAC,KAAM,OAAM,IAAI,UAAU,6BAA6B,CAAC,EAAE;AAE/D,aAAO,KAAK,EAAE,MAAM,QAAQ,OAAO,GAAG,OAAO,KAAK,CAAC;AACnD,UAAI;AACJ;AAAA,IACF;AAEA,QAAI,SAAS,KAAK;AAChB,UAAI,QAAQ;AACZ,UAAI,UAAU;AACd,UAAI,IAAI,IAAI;AAEZ,UAAI,IAAI,CAAC,MAAM,KAAK;AAClB,cAAM,IAAI,UAAU,oCAAoC,CAAC,EAAE;AAAA,MAC7D;AAEA,aAAO,IAAI,IAAI,QAAQ;AACrB,YAAI,IAAI,CAAC,MAAM,MAAM;AACnB,qBAAW,IAAI,GAAG,IAAI,IAAI,GAAG;AAC7B;AAAA,QACF;AAEA,YAAI,IAAI,CAAC,MAAM,KAAK;AAClB;AACA,cAAI,UAAU,GAAG;AACf;AACA;AAAA,UACF;AAAA,QACF,WAAW,IAAI,CAAC,MAAM,KAAK;AACzB;AACA,cAAI,IAAI,IAAI,CAAC,MAAM,KAAK;AACtB,kBAAM,IAAI,UAAU,uCAAuC,CAAC,EAAE;AAAA,UAChE;AAAA,QACF;AAEA,mBAAW,IAAI,GAAG;AAAA,MACpB;AAEA,UAAI,MAAO,OAAM,IAAI,UAAU,yBAAyB,CAAC,EAAE;AAC3D,UAAI,CAAC,QAAS,OAAM,IAAI,UAAU,sBAAsB,CAAC,EAAE;AAE3D,aAAO,KAAK,EAAE,MAAM,WAAW,OAAO,GAAG,OAAO,QAAQ,CAAC;AACzD,UAAI;AACJ;AAAA,IACF;AAEA,WAAO,KAAK,EAAE,MAAM,QAAQ,OAAO,GAAG,OAAO,IAAI,GAAG,EAAE,CAAC;AAAA,EACzD;AAEA,SAAO,KAAK,EAAE,MAAM,OAAO,OAAO,GAAG,OAAO,GAAG,CAAC;AAEhD,SAAO;AACT;AAKO,SAAS,MAAM,KAAK,UAAU,CAAC,GAAG;AACvC,QAAM,SAAS,MAAM,GAAG;AACxB,QAAM,EAAE,WAAW,MAAM,YAAY,MAAM,IAAI;AAC/C,QAAM,SAAS,CAAC;AAChB,MAAI,MAAM;AACV,MAAI,IAAI;AACR,MAAI,OAAO;AAEX,QAAM,aAAa,CAAC,SAAS;AAC3B,QAAI,IAAI,OAAO,UAAU,OAAO,CAAC,EAAE,SAAS,KAAM,QAAO,OAAO,GAAG,EAAE;AAAA,EACvE;AAEA,QAAM,cAAc,CAAC,SAAS;AAC5B,UAAM,QAAQ,WAAW,IAAI;AAC7B,QAAI,UAAU,OAAW,QAAO;AAChC,UAAM,EAAE,MAAM,UAAU,MAAM,IAAI,OAAO,CAAC;AAC1C,UAAM,IAAI,UAAU,cAAc,QAAQ,OAAO,KAAK,cAAc,IAAI,EAAE;AAAA,EAC5E;AAEA,QAAM,cAAc,MAAM;AACxB,QAAII,UAAS;AACb,QAAI;AACJ,WAAQ,QAAQ,WAAW,MAAM,KAAK,WAAW,cAAc,GAAI;AACjE,MAAAA,WAAU;AAAA,IACZ;AACA,WAAOA;AAAA,EACT;AAEA,QAAM,SAAS,CAAC,UAAU;AACxB,eAAW,QAAQ,UAAW,KAAI,MAAM,QAAQ,IAAI,IAAI,GAAI,QAAO;AACnE,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,CAAC,WAAW;AAC9B,UAAM,OAAO,OAAO,OAAO,SAAS,CAAC;AACrC,UAAM,WAAW,WAAW,QAAQ,OAAO,SAAS,WAAW,OAAO;AAEtE,QAAI,QAAQ,CAAC,UAAU;AACrB,YAAM,IAAI;AAAA,QACR,8DAA8D,KAAK,IAAI;AAAA,MACzE;AAAA,IACF;AAEA,QAAI,CAAC,YAAY,OAAO,QAAQ,EAAG,QAAO,KAAK,aAAa,SAAS,CAAC;AACtE,WAAO,SAAS,aAAa,QAAQ,CAAC,MAAM,aAAa,SAAS,CAAC;AAAA,EACrE;AAEA,SAAO,IAAI,OAAO,QAAQ;AACxB,UAAM,OAAO,WAAW,MAAM;AAC9B,UAAM,OAAO,WAAW,MAAM;AAC9B,UAAM,UAAU,WAAW,SAAS;AAEpC,QAAI,QAAQ,SAAS;AACnB,UAAI,SAAS,QAAQ;AAErB,UAAI,SAAS,QAAQ,MAAM,MAAM,IAAI;AACnC,gBAAQ;AACR,iBAAS;AAAA,MACX;AAEA,UAAI,MAAM;AACR,eAAO,KAAK,IAAI;AAChB,eAAO;AAAA,MACT;AAEA,aAAO,KAAK;AAAA,QACV,MAAM,QAAQ;AAAA,QACd;AAAA,QACA,QAAQ;AAAA,QACR,SAAS,WAAW,YAAY,MAAM;AAAA,QACtC,UAAU,WAAW,UAAU,KAAK;AAAA,MACtC,CAAC;AACD;AAAA,IACF;AAEA,UAAM,QAAQ,QAAQ,WAAW,cAAc;AAC/C,QAAI,OAAO;AACT,cAAQ;AACR;AAAA,IACF;AAEA,QAAI,MAAM;AACR,aAAO,KAAK,IAAI;AAChB,aAAO;AAAA,IACT;AAEA,UAAM,OAAO,WAAW,MAAM;AAC9B,QAAI,MAAM;AACR,YAAM,SAAS,YAAY;AAC3B,YAAMC,QAAO,WAAW,MAAM,KAAK;AACnC,YAAMC,WAAU,WAAW,SAAS,KAAK;AACzC,YAAM,SAAS,YAAY;AAE3B,kBAAY,OAAO;AAEnB,aAAO,KAAK;AAAA,QACV,MAAMD,UAASC,WAAU,QAAQ;AAAA,QACjC,SAASD,SAAQ,CAACC,WAAU,YAAY,MAAM,IAAIA;AAAA,QAClD;AAAA,QACA;AAAA,QACA,UAAU,WAAW,UAAU,KAAK;AAAA,MACtC,CAAC;AACD;AAAA,IACF;AAEA,gBAAY,KAAK;AAAA,EACnB;AAEA,SAAO;AACT;AA4FO,SAAS,MAAM,KAAK,SAAS;AAClC,QAAM,OAAO,CAAC;AACd,QAAM,KAAK,aAAa,KAAK,MAAM,OAAO;AAC1C,SAAO,iBAAiB,IAAI,MAAM,OAAO;AAC3C;AAKO,SAAS,iBAAiB,IAAI,MAAM,UAAU,CAAC,GAAG;AACvD,QAAM,EAAE,SAAS,CAAC,MAAM,EAAE,IAAI;AAE9B,SAAO,SAAU,UAAU;AACzB,UAAM,IAAI,GAAG,KAAK,QAAQ;AAC1B,QAAI,CAAC,EAAG,QAAO;AAEf,UAAM,EAAE,GAAG,MAAM,MAAM,IAAI;AAC3B,UAAM,SAAS,uBAAO,OAAO,IAAI;AAEjC,aAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,UAAI,EAAE,CAAC,MAAM,OAAW;AAExB,YAAM,MAAM,KAAK,IAAI,CAAC;AAEtB,UAAI,IAAI,aAAa,OAAO,IAAI,aAAa,KAAK;AAChD,eAAO,IAAI,IAAI,IAAI,EAAE,CAAC,EAAE,MAAM,IAAI,SAAS,IAAI,MAAM,EAAE,IAAI,CAAC,UAAU;AACpE,iBAAO,OAAO,OAAO,GAAG;AAAA,QAC1B,CAAC;AAAA,MACH,OAAO;AACL,eAAO,IAAI,IAAI,IAAI,OAAO,EAAE,CAAC,GAAG,GAAG;AAAA,MACrC;AAAA,IACF;AAEA,WAAO,EAAE,MAAM,OAAO,OAAO;AAAA,EAC/B;AACF;AAKA,SAAS,aAAa,KAAK;AACzB,SAAO,IAAI,QAAQ,6BAA6B,MAAM;AACxD;AAKA,SAAS,MAAM,SAAS;AACtB,SAAO,WAAW,QAAQ,YAAY,KAAK;AAC7C;AAKA,SAAS,eAAe,MAAM,MAAM;AAClC,MAAI,CAAC,KAAM,QAAO;AAElB,QAAM,cAAc;AAEpB,MAAI,QAAQ;AACZ,MAAI,aAAa,YAAY,KAAK,KAAK,MAAM;AAC7C,SAAO,YAAY;AACjB,SAAK,KAAK;AAAA;AAAA,MAER,MAAM,WAAW,CAAC,KAAK;AAAA,MACvB,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,SAAS;AAAA,IACX,CAAC;AACD,iBAAa,YAAY,KAAK,KAAK,MAAM;AAAA,EAC3C;AAEA,SAAO;AACT;AAKA,SAAS,cAAc,OAAO,MAAM,SAAS;AAC3C,QAAM,QAAQ,MAAM,IAAI,CAAC,SAAS,aAAa,MAAM,MAAM,OAAO,EAAE,MAAM;AAC1E,SAAO,IAAI,OAAO,MAAM,MAAM,KAAK,GAAG,CAAC,KAAK,MAAM,OAAO,CAAC;AAC5D;AAKA,SAAS,eAAe,MAAM,MAAM,SAAS;AAC3C,SAAO,eAAe,MAAM,MAAM,OAAO,GAAG,MAAM,OAAO;AAC3D;AAKO,SAAS,eAAe,QAAQ,MAAM,UAAU,CAAC,GAAG;AACzD,QAAM;AAAA,IACJ,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,SAAS,CAAC,MAAM;AAAA,IAChB,YAAY;AAAA,IACZ,WAAW;AAAA,EACb,IAAI;AACJ,QAAM,aAAa,IAAI,aAAa,QAAQ,CAAC;AAC7C,QAAM,cAAc,IAAI,aAAa,SAAS,CAAC;AAC/C,MAAI,QAAQ,QAAQ,MAAM;AAG1B,aAAW,SAAS,QAAQ;AAC1B,QAAI,OAAO,UAAU,UAAU;AAC7B,eAAS,aAAa,OAAO,KAAK,CAAC;AAAA,IACrC,OAAO;AACL,YAAM,SAAS,aAAa,OAAO,MAAM,MAAM,CAAC;AAChD,YAAM,SAAS,aAAa,OAAO,MAAM,MAAM,CAAC;AAEhD,UAAI,MAAM,SAAS;AACjB,YAAI,KAAM,MAAK,KAAK,KAAK;AAEzB,YAAI,UAAU,QAAQ;AACpB,cAAI,MAAM,aAAa,OAAO,MAAM,aAAa,KAAK;AACpD,kBAAM,MAAM,MAAM,aAAa,MAAM,MAAM;AAC3C,qBAAS,MAAM,MAAM,OAAO,MAAM,OAAO,OAAO,MAAM,GAAG,MAAM,MAAM,MAAM,OAAO,OAAO,MAAM,IAAI,GAAG;AAAA,UACxG,OAAO;AACL,qBAAS,MAAM,MAAM,IAAI,MAAM,OAAO,IAAI,MAAM,IAAI,MAAM,QAAQ;AAAA,UACpE;AAAA,QACF,OAAO;AACL,cAAI,MAAM,aAAa,OAAO,MAAM,aAAa,KAAK;AACpD,kBAAM,IAAI;AAAA,cACR,mBAAmB,MAAM,IAAI;AAAA,YAC/B;AAAA,UACF;AAEA,mBAAS,IAAI,MAAM,OAAO,IAAI,MAAM,QAAQ;AAAA,QAC9C;AAAA,MACF,OAAO;AACL,iBAAS,MAAM,MAAM,GAAG,MAAM,IAAI,MAAM,QAAQ;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAEA,MAAI,KAAK;AACP,QAAI,CAAC,OAAQ,UAAS,GAAG,WAAW;AAEpC,aAAS,CAAC,QAAQ,WAAW,MAAM,MAAM,UAAU;AAAA,EACrD,OAAO;AACL,UAAM,WAAW,OAAO,OAAO,SAAS,CAAC;AACzC,UAAM,iBACJ,OAAO,aAAa,WAChB,YAAY,QAAQ,SAAS,SAAS,SAAS,CAAC,CAAC,IAAI,KACrD,aAAa;AAEnB,QAAI,CAAC,QAAQ;AACX,eAAS,MAAM,WAAW,MAAM,UAAU;AAAA,IAC5C;AAEA,QAAI,CAAC,gBAAgB;AACnB,eAAS,MAAM,WAAW,IAAI,UAAU;AAAA,IAC1C;AAAA,EACF;AAEA,SAAO,IAAI,OAAO,OAAO,MAAM,OAAO,CAAC;AACzC;AASO,SAAS,aAAa,MAAM,MAAM,SAAS;AAChD,MAAI,gBAAgB,OAAQ,QAAO,eAAe,MAAM,IAAI;AAC5D,MAAI,MAAM,QAAQ,IAAI,EAAG,QAAO,cAAc,MAAM,MAAM,OAAO;AACjE,SAAO,eAAe,MAAM,MAAM,OAAO;AAC3C;;;ADneA,IAAM,aAAa,MACjB,oCAAC,SAAI,OAAO,EAAE,SAAS,GAAG,KACxB,oCAAC,YAAG,KAAG,GACP,oCAAC,WAAE,gBAAc,CACnB;AAGF,IAAM,WAAW,CAAC,gBAAgBC,cAAa;AAC7C,aAAW,KAAK,gBAAgB;AAC9B,UAAM,MAAM,EAAE,QAAQA,SAAQ;AAC9B,QAAI,KAAK;AACP,aAAO,EAAE,OAAO,GAAG,QAAQ,IAAI,UAAU,CAAC,EAAE;AAAA,IAC9C;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAO,iBAAQ;AAAA,EACb,OAAO,CAAC,gBAAgBA,cAAa;AACnC,UAAM,IAAI,SAAS,gBAAgBA,SAAQ;AAC3C,QAAI,CAAC,EAAG,QAAO,EAAE,WAAW,YAAY,YAAY,MAAM,QAAQ,CAAC,EAAE;AACrE,UAAM,EAAE,OAAO,OAAO,IAAI;AAC1B,UAAM,EAAE,WAAW,WAAW,IAAI;AAClC,WAAO,EAAE,WAAW,YAAY,OAAO;AAAA,EACzC;AAAA,EACA,SAAS,CAACC,eACR,OAAO,KAAKA,UAAS,EAAE,IAAI,CAAC,SAAS;AACnC,UAAM,OAAOA,WAAU,IAAI;AAC3B,QAAI,WAAW;AACf,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,OAAC,WAAW,UAAU,IAAI;AAAA,IAC5B,OAAO;AACL,kBAAY;AAAA,IACd;AACA,WAAO;AAAA,MACL;AAAA,MACA,SAAS,MAAM,MAAM,EAAE,QAAQ,mBAAmB,CAAC;AAAA,MACnD,WAAW;AAAA,MACX,YAAY,cAAc;AAAA,IAC5B;AAAA,EACF,CAAC;AACL;;;AE1CA,IAAM,WAAW,MAAM;AAErB,MAAI,OAAO,eAAe,eAAe,WAAW,QAAQ;AAC1D,QAAI,OAAO,WAAW,OAAO,eAAe,YAAY;AACtD,aAAO,WAAW,OAAO,WAAW;AAAA,IACtC;AAEA,UAAM,MAAM,IAAI,WAAW,EAAE;AAC7B,eAAW,OAAO,gBAAgB,GAAG;AACrC,QAAI,CAAC,IAAK,IAAI,CAAC,IAAI,KAAQ;AAC3B,QAAI,CAAC,IAAK,IAAI,CAAC,IAAI,KAAQ;AAC3B,UAAM,MAAM,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAC/D,WAAO,GAAG,IAAI,MAAM,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,IAAI,IAAI,MAAM,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,IAAI,IAC/D,MAAM,GAAG,CAAC,EACV,KAAK,EAAE,CAAC,IAAI,IAAI,MAAM,GAAG,EAAE,EAAE,KAAK,EAAE,CAAC,IAAI,IAAI,MAAM,EAAE,EAAE,KAAK,EAAE,CAAC;AAAA,EACpE;AAEA,MAAI;AACF,UAAM,EAAE,WAAW,IAAI,UAAQ,aAAa;AAC5C,QAAI,OAAO,eAAe,WAAY,QAAO,WAAW;AAAA,EAC1D,QAAQ;AAAA,EAAC;AAET,SAAO,uCAAuC,QAAQ,SAAS,CAAC,MAAM;AACpE,UAAM,IAAK,KAAK,OAAO,IAAI,KAAM;AACjC,UAAM,IAAI,MAAM,MAAM,IAAK,IAAI,IAAO;AACtC,WAAO,EAAE,SAAS,EAAE;AAAA,EACtB,CAAC;AACH;AAEA,IAAM,YAAY,OAAO,IAAI,+BAA+B;AAC5D,IAAI,YAAY;AAEhB,SAAS,WAAW;AAClB,MAAI;AACF,QACE,OAAO,WAAW,eAClB,OAAO,YACP,OAAO,SAAS,QAChB;AACA,aAAO,OAAO,SAAS;AAAA,IACzB;AAAA,EACF,SAAS,GAAG;AAAA,EAAC;AACb,SAAO;AACT;AAEA,SAAS,SAAS,KAAK;AACrB,QAAM,MAAM,IAAI,KAAK,IAAI,YAAY,QAAQ,IAAI,UAAU,KAAK,SAAS,CAAC;AAC1E,MAAI,aAAa,IAAI,QAAQ,SAAS,CAAC;AACvC,SAAO,IAAI,SAAS;AACtB;AAEA,SAAS,SAAS,QAAQ;AACxB,MAAI,WAAW,IAAK,QAAO;AAC3B,MAAI,KAAK,MAAM,SAAS,GAAG,MAAM,EAAG,QAAO;AAC3C,SAAO;AACT;AAEe,SAAR,oBACL,UACA;AAAA,EACE;AAAA,EACA,YAAa,OAAO,UAAU,eAAe,SAAU;AAAA,EACvD,WAAW,SAAU,GAAG;AACtB,QAAI,OAAO,aAAa,eAAe,EAAG,UAAS,QAAQ;AAAA,EAC7D;AAAA,EACA,WAAW,EAAE,QAAQ;AAAA,EAAC,GAAG,OAAO;AAAA,EAAC,EAAE;AAAA;AACrC,IAAI,CAAC,GACL;AACA,MAAI,CAAC,WAAW,CAAC,WAAW;AAC1B;AAAA,EACF;AAEA,MAAI,QAAQ,SAAS,GAAG;AACtB;AAAA,EACF;AACA,UAAQ,SAAS,IAAI;AAErB,UAAQ,OAAO,SAAU,EAAE,UAAAC,WAAU,OAAO,GAAG;AAE7C,QAAI,aAAa,OAAO,UAAU,UAAU,YAAY;AACtD,UAAI;AACF,kBAAU,MAAM;AAAA,MAClB,SAAS,GAAG;AAAA,MAAC;AAAA,IACf;AACA,gBACE,OAAO,oBAAoB,cAAc,IAAI,gBAAgB,IAAI;AAEnE,QAAI,YAAY,OAAO,SAAS,SAAS,WAAY,UAAS,KAAK;AACnE,QAAI,YAAY,OAAO,SAAS,UAAU,WAAY,UAAS,MAAM;AAErE,UAAM,MAAM,SAASA,SAAQ;AAG7B,YAAQ;AAAA,MACN,UAAU,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,SAAS,EAAE,QAAQ,mBAAmB;AAAA,QACtC,QAAQ,YAAY,UAAU,SAAS;AAAA,MACzC,CAAC;AAAA,IACH,EACG,KAAK,SAAU,KAAK;AACnB,YAAM,KAAK,OAAO,IAAI,OAAO,IAAI,KAAK,IAAI,CAAC;AAC3C,aAAO,QAAQ,QAAQ,EAAE,EACtB,KAAK,SAAU,MAAM;AACpB,eAAO,EAAE,QAAQ,MAAM,IAAI,SAAS,KAAK,MAAM,QAAQ,CAAC,EAAE;AAAA,MAC5D,CAAC,EACA,MAAM,WAAY;AACjB,eAAO,EAAE,QAAQ,MAAM,IAAI,SAAS,KAAK,MAAM,CAAC,EAAE;AAAA,MACpD,CAAC;AAAA,IACL,CAAC,EACA,MAAM,SAAU,KAAK;AACpB,aAAO,EAAE,QAAQ,KAAK,MAAM,CAAC,EAAE;AAAA,IACjC,CAAC,EACA,KAAK,SAAU,EAAE,QAAQ,KAAK,GAAG;AAChC,UAAI,YAAY,OAAO,SAAS,SAAS,WAAY,UAAS,KAAK;AAGnE,YAAM,UACJ,QAAQ,KAAK,iBAAiB,KAAK,cAAc;AACnD,UAAI,WAAW,WAAWA,UAAS,YAAY;AAG/C,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,SAAS,MAAM;AACzB,YAAI,MAAM,MAAO,YAAW;AAAA,iBACnB,MAAM,MAAO,YAAW;AAAA,MACnC;AAEA,eAAS;AAAA,QACP,MAAM;AAAA,QACN,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,EAAE,UAAU,SAAS,CAAC;AAAA,MACtD,CAAC;AAGD,UAAI,QAAQ,KAAK,OAAO;AAEtB,iBAAS,KAAK,KAAK;AAAA,MACrB;AAGA,UAAI,OAAO,WAAW,eAAe,OAAO,UAAU;AACpD,YAAI,WAAW,QAAQ;AACrB,iBAAO,SAAS,GAAG,CAAC;AAAA,QACtB,OAAO;AACL,gBAAM,OAAOA,UAAS,YAAY,QAAQA,UAAS,UAAU;AAC7D,gBAAM,OAAO,4BAA4B,GAAG;AAC5C,cAAI,MAAM;AACR,uBAAW,WAAY;AACrB,qBAAO,SAAS,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC;AAAA,YAC1C,GAAG,GAAG;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACL,CAAC;AACH;;;APvJA,IAAI,uBAAuB;AAEpB,IAAM,OAAO,CAAC;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP;AAAA,EACA;AAAA,EACA,QAAQ,CAAC;AAAA,EACT,GAAG;AACL,MAAM;AACJ,QAAM,UAAU,CAAC,MAAM;AACrB,QACE,EAAE,oBACF,EAAE,WAAW,KACb,EAAE,WACF,EAAE,WACF,EAAE,UACF,EAAE,UACF;AACA;AAAA,IACF;AACA,MAAE,eAAe;AACjB,8BAA0B;AAC1B,QAAI,CAAC,gBAAY;AACjB,QAAI,SAAS,WAAW;AACtB,sBAAW,QAAQ,EAAE;AAAA,IACvB,OAAO;AACL,sBAAW,KAAK,EAAE;AAAA,IACpB;AAAA,EACF;AAEA,SACE,gBAAAC,OAAA;AAAA,IAAC;AAAA;AAAA,MACC,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACC,GAAG;AAAA;AAAA,IAEH;AAAA,EACH;AAEJ;AAYO,IAAM,eAAe,CAAC,QAAQ,UAAU;AAC7C,MAAI,CAAC,OAAO;AACV,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,MAAM;AAEnB,UAAM,oBAAoBC,OAAM,OAAO,IAAI;AAC3C,QAAI,CAAC,kBAAkB,SAAS;AAC9B,wBAAkB,UAAU,eAAO,QAAQ,MAAM;AAAA,IACnD;AAGA,UAAM,WAAWA,OAAM,WAAW,KAAK;AACvC,QACE,CAAC,YACD,OAAO,aAAa,YACpB,EAAE,WAAW,aACb,OAAO,SAAS,aAAa,YAC7B;AACA,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,EAAE,OAAO,SAAS,IAAI;AAG5B,IAAAA,OAAM,UAAU,MAAM;AACpB,UAAI,CAAC,YAAY,CAAC,gBAAY;AAE9B,YAAM,WAAW,gBAAW,OAAO,CAAC,EAAE,UAAAC,UAAS,MAAM;AACnD,cAAM,UAAUA,UAAS,YAAYA,UAAS,UAAU;AACxD,iBAAS,EAAE,MAAM,oBAAoB,UAAU,QAAQ,CAAC;AAAA,MAC1D,CAAC;AAGD,eAAS;AAAA,QACP,MAAM;AAAA,QACN,UACE,gBAAW,SAAS,YAAY,gBAAW,SAAS,UAAU;AAAA,MAClE,CAAC;AAED,aAAO,MAAM,SAAS;AAAA,IACxB,GAAG,CAAC,QAAQ,CAAC;AAGb,IAAAD,OAAM,UAAU,MAAM;AACpB,UAAI,CAAC,wBAAwB,UAAU;AACrC,4BAAoB,QAAQ;AAC5B,+BAAuB;AAAA,MACzB;AAAA,IACF,GAAG,CAAC,QAAQ,CAAC;AAGb,UAAM,kBAAkB,MAAM,YAAY;AAC1C,UAAM,WAAW,gBAAgB,MAAM,KAAK,CAAC,EAAE,CAAC;AAEhD,UAAM,EAAE,WAAW,OAAO,IAAI,eAAO;AAAA,MACnC,kBAAkB;AAAA,MAClB;AAAA,IACF;AAEA,WAAO,gBAAAA,OAAA,cAAC,aAAW,GAAG,OAAO,QAAgB,UAAoB;AAAA,EACnE;AAEA,SAAO;AACT;;;AQrIA,OAAOE,YAAW;AAGX,IAAM,OAAO,CAAC,UAAU;AAC7B,SACE,gBAAAC,OAAA,cAAC,SAAI,OAAO,EAAE,SAAS,GAAG,KACxB,gBAAAA,OAAA,cAAC,YAAG,MAAI,GACR,gBAAAA,OAAA,cAAC,WAAE,kDAAgD,GACnD,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,SAAS,QAAQ,KAAK,GAAG,KACrC,gBAAAA,OAAA,cAAC,QAAK,IAAG,OAAI,MAAI,GACjB,gBAAAA,OAAA,cAAC,QAAK,IAAG,YAAS,OAAK,GACvB,gBAAAA,OAAA,cAAC,QAAK,IAAG,eAAY,SAAO,CAC9B,GACA,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,YAAY,WAAW,SAAS,IAAI,WAAW,GAAG,KAC7D,KAAK,UAAU,EAAE,OAAO,MAAM,GAAG,MAAM,CAAC,CAC3C,CACF;AAEJ;AAEO,IAAM,QAAQ,CAAC,UAAU;AAC9B,SACE,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,SAAS,GAAG,KACxB,gBAAAA,OAAA,cAAC,YAAG,OAAK,GACT,gBAAAA,OAAA,cAAC,WAAE,yDAAuD,GAC1D,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,SAAS,QAAQ,KAAK,GAAG,KACrC,gBAAAA,OAAA,cAAC,QAAK,IAAG,OAAI,MAAI,GACjB,gBAAAA,OAAA,cAAC,QAAK,IAAG,YAAS,OAAK,GACvB,gBAAAA,OAAA,cAAC,QAAK,IAAG,gBAAa,UAAQ,CAChC,GACA,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,YAAY,WAAW,SAAS,IAAI,WAAW,GAAG,KAC7D,KAAK,UAAU,EAAE,OAAO,MAAM,GAAG,MAAM,CAAC,CAC3C,CACF;AAEJ;AAEO,IAAM,OAAO,CAAC,EAAE,QAAQ,GAAG,MAAM,MAAM;AAC5C,SACE,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,SAAS,GAAG,KACxB,gBAAAA,OAAA,cAAC,YAAG,MAAI,GACR,gBAAAA,OAAA,cAAC,WAAE,aACQ,gBAAAA,OAAA,cAAC,gBAAQ,OAAO,EAAG,CAC9B,GACA,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,SAAS,QAAQ,KAAK,GAAG,KACrC,gBAAAA,OAAA,cAAC,QAAK,IAAG,OAAI,MAAI,GACjB,gBAAAA,OAAA,cAAC,QAAK,IAAG,YAAS,OAAK,CACzB,GACA,gBAAAA,OAAA,cAAC,SAAI,OAAO,EAAE,YAAY,WAAW,SAAS,IAAI,WAAW,GAAG,KAC7D,KAAK,UAAU,EAAE,QAAQ,OAAO,MAAM,GAAG,MAAM,CAAC,CACnD,CACF;AAEJ;AAEA,IAAM,YAAY;AAAA,EAChB,KAAK;AAAA,EACL,UAAU;AAAA,EACV,cAAc;AAChB;AAEA,IAAO,iBAAQ;;;AC7DR,IAAM,eAAe;AAAA,EAC1B,UAAU;AAAA,EACV,OAAO;AAAA,EACP,UAAU,CAAC;AACb;AAEe,SAAR,QAAyB,OAAO,QAAQ;AAC7C,UAAQ,OAAO,MAAM;AAAA,IACnB,KAAK,oBAAoB;AACvB,aAAO,EAAE,GAAG,OAAO,UAAU,OAAO,SAAS;AAAA,IAC/C;AAAA,IACA,KAAK,eAAe;AAClB,YAAM,OAAO,EAAE,GAAG,OAAO,GAAG,OAAO,KAAK;AAExC,UAAI,OAAO,QAAQ,OAAO,KAAK,UAAU;AACvC,aAAK,WAAW,OAAO,KAAK;AAAA,MAC9B;AACA,aAAO;AAAA,IACT;AAAA,IACA;AACE,aAAO;AAAA,EACX;AACF;;;AXjBA,iBAAiB;AAOV,IAAM,eAAe,cAAc,IAAI;AAE9C,IAAM,gBAAgB,CAAC,EAAE,SAAS,MAAM;AACtC,QAAM,CAAC,OAAO,QAAQ,IAAI,WAAW,SAAS,YAAY;AAC1D,SACE,gBAAAC,OAAA,cAAC,aAAa,UAAb,EAAsB,OAAO,EAAE,OAAO,SAAS,KAC7C,QACH;AAEJ;AAGA,IAAM,YAAY,aAAa,gBAAW,YAAY;AAEtD,IAAM,OAAO,WAAW,SAAS,eAAe,MAAM,CAAC;AACvD,KAAK;AAAA,EACH,gBAAAA,OAAA,cAAC,qBACC,gBAAAA,OAAA,cAAC,eAAU,CACb;AACF;",
  "names": ["React", "React", "Action", "window", "location", "index", "action", "result", "name", "pattern", "location", "routesMap", "location", "React", "React", "location", "React", "React", "React"]
}
