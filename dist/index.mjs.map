{"version":3,"sources":["../src/router.tsx","../src/history.ts","../src/helper.ts","../src/scroll.ts","../src/handleHistoryChange.ts"],"sourcesContent":["import React, {\n  useContext,\n  useMemo,\n  useRef,\n  useSyncExternalStore,\n  type AnchorHTMLAttributes,\n  type ComponentType,\n  type Context,\n  type MouseEvent,\n} from \"react\";\nimport type { BrowserHistory } from \"history\";\nimport history from \"./history\";\nimport helper, {\n  type PreparedRoute,\n  type RouteMatchResult,\n  type RoutesInput,\n} from \"./helper\";\n\nexport type LinkTo =\n  | string\n  | {\n      pathname: string;\n      search?: string;\n      hash?: string;\n    };\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: unknown;\n}\n\nexport interface LinkProps\n  extends Omit<AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  to: LinkTo;\n  replace?: boolean;\n  state?: unknown;\n}\n\ninterface StoreContextValue {\n  state: Record<string, any>;\n  dispatch: ((action: Record<string, unknown>) => void) | false;\n  pageRefresher?: unknown;\n}\n\nconst appHistory: BrowserHistory | null = history;\n\nconst getHistoryOrThrow = (): BrowserHistory => {\n  if (!appHistory) {\n    throw new Error(\n      \"History is unavailable in this environment. Use makeMemoryHistory for non-browser usage.\",\n    );\n  }\n  return appHistory;\n};\n\nexport const navigate = (to: LinkTo, options: NavigateOptions = {}): void => {\n  const { replace = false, state } = options;\n  const activeHistory = getHistoryOrThrow();\n  if (replace) activeHistory.replace(to, state);\n  else activeHistory.push(to, state);\n};\n\nconst toHref = (to: LinkTo): string => {\n  if (typeof to === \"string\") return to;\n  const { pathname, search = \"\", hash = \"\" } = to;\n  if (typeof pathname !== \"string\" || pathname.length === 0) {\n    throw new TypeError(\"Location object 'pathname' must be a non-empty string\");\n  }\n  return `${pathname}${search}${hash}`;\n};\n\nconst isHttpLikeHref = (href: string): boolean => {\n  if (href.startsWith(\"//\")) return false;\n  if (\n    href.startsWith(\"/\") ||\n    href.startsWith(\"./\") ||\n    href.startsWith(\"../\") ||\n    href.startsWith(\"?\") ||\n    href.startsWith(\"#\")\n  ) {\n    return true;\n  }\n  const protocolMatch = href.match(/^([a-zA-Z][a-zA-Z\\d+.-]*):/);\n  if (!protocolMatch) return true;\n  const protocol = protocolMatch[1].toLowerCase();\n  if (protocol !== \"http\" && protocol !== \"https\") return false;\n  if (typeof window === \"undefined\" || !window.location) return false;\n  try {\n    return new URL(href, window.location.href).origin === window.location.origin;\n  } catch {\n    return false;\n  }\n};\n\nconst toClientPath = (to: LinkTo, href: string): LinkTo => {\n  if (typeof to !== \"string\") return to;\n  if (!/^https?:/i.test(href)) return to;\n  try {\n    const url = new URL(href, window.location.href);\n    return `${url.pathname}${url.search}${url.hash}`;\n  } catch {\n    return to;\n  }\n};\n\nconst shouldHandleClientNavigation = (\n  event: MouseEvent<HTMLAnchorElement>,\n  anchorProps: { target?: string; download?: string; href: string },\n): boolean => {\n  if (\n    event.defaultPrevented ||\n    event.button !== 0 ||\n    event.metaKey ||\n    event.altKey ||\n    event.ctrlKey ||\n    event.shiftKey\n  ) {\n    return false;\n  }\n  const { target, download, href } = anchorProps;\n  if (download !== undefined) return false;\n  if (target && target !== \"_self\") return false;\n  return isHttpLikeHref(href);\n};\n\nexport const Link: React.FC<LinkProps> = ({\n  to,\n  replace = false,\n  state,\n  onClick,\n  ...rest\n}) => {\n  const href = toHref(to);\n\n  const handleClick = (e: MouseEvent<HTMLAnchorElement>): void => {\n    if (onClick) onClick(e);\n    if (!shouldHandleClientNavigation(e, { ...rest, href })) return;\n    e.preventDefault();\n    const activeHistory = getHistoryOrThrow();\n    const nextTo = toClientPath(to, href);\n    if (replace) activeHistory.replace(nextTo, state);\n    else activeHistory.push(nextTo, state);\n  };\n\n  return <a href={href} onClick={handleClick} {...rest} />;\n};\n\nconst matchRoute = (\n  routes: RoutesInput | PreparedRoute[],\n  pathname: string,\n): RouteMatchResult => helper.match(routes, pathname);\n\nexport const createRouter = (\n  routes: RoutesInput,\n  storeContext?: Context<StoreContextValue>,\n): React.FC<Record<string, any>> => {\n  const Router: React.FC<Record<string, any>> = (props) => {\n    const appState: StoreContextValue =\n      (storeContext && useContext(storeContext)) || { state: props, dispatch: false };\n\n    const { pageRefresher } = appState;\n    const { state, dispatch } = appState;\n\n    const preparedRoutes = useMemo(() => helper.prepare(routes), [routes]);\n\n    const readHistoryLocation = (): string =>\n      (history?.location?.pathname || \"\") + (history?.location?.search || \"\");\n    const initialLocation = (state && state.location) || readHistoryLocation();\n    const lastLocRef = useRef(initialLocation);\n    const hasNavigationRef = useRef(false);\n    const getLocationSnapshot = (): string =>\n      hasNavigationRef.current ? readHistoryLocation() : initialLocation;\n\n    const loc = useSyncExternalStore(\n      (onStoreChange) => {\n        if (!history || typeof history.listen !== \"function\") return () => {};\n        const unlisten = history.listen(({ location, action }) => {\n          const nextLoc = (location.pathname || \"\") + (location.search || \"\");\n          if (nextLoc !== lastLocRef.current) {\n            lastLocRef.current = nextLoc;\n            hasNavigationRef.current = true;\n            if (typeof dispatch === \"function\") {\n              dispatch({\n                type: \"LOCATION_CHANGED\",\n                location: nextLoc,\n                meta: { action },\n              });\n            }\n          }\n          onStoreChange();\n        });\n        return () => {\n          if (typeof unlisten === \"function\") unlisten();\n        };\n      },\n      getLocationSnapshot,\n      getLocationSnapshot,\n    );\n\n    const activePathname = (loc || \"\").split(\"?\")[0];\n    const matched = useMemo(\n      () => matchRoute(preparedRoutes, activePathname),\n      [preparedRoutes, activePathname],\n    );\n\n    const Component: ComponentType<any> = matched?.Component || (() => null);\n    const routeParams = matched?.params || {};\n\n    return (\n      <Component\n        {...state}\n        {...routeParams}\n        dispatch={dispatch}\n        pageRefresher={pageRefresher}\n      />\n    );\n  };\n\n  return Router;\n};\n\nexport default createRouter;\n","// Modernized history singleton with test-friendly exports (ESM)\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  type BrowserHistory,\n  type MemoryHistory,\n} from \"history\";\n\nexport const appHistory: BrowserHistory | null =\n  typeof window !== \"undefined\" &&\n  window.document &&\n  typeof window.document.createElement === \"function\"\n    ? createBrowserHistory()\n    : null;\n\nexport const makeMemoryHistory = (initialEntries: string[] = [\"/\"]): MemoryHistory =>\n  createMemoryHistory({ initialEntries });\n\nexport default appHistory;\n","// src/helper.ts\n// Route preparation & matching utility for Universal Route.\n// Accepts either an array of route objects OR a map of { \"/path\": Component | [Component, reducerKey] }.\nimport type { ComponentType } from \"react\";\n\nexport interface RouteDefinition {\n  path: string;\n  Component?: ComponentType<any>;\n  element?: ComponentType<any>;\n  render?: ComponentType<any>;\n  reducerKey?: string;\n}\n\nexport type RouteMapValue =\n  | ComponentType<any>\n  | [ComponentType<any>]\n  | [ComponentType<any>, string]\n  | {\n      Component?: ComponentType<any>;\n      element?: ComponentType<any>;\n      render?: ComponentType<any>;\n      reducerKey?: string;\n    };\n\nexport type RouteMap = Record<string, RouteMapValue>;\n\nexport type RoutesInput = RouteDefinition[] | RouteMap;\n\nexport interface PreparedRoute {\n  path: string;\n  Component: ComponentType<any>;\n  reducerKey?: string;\n  matcher: (pathname: string) => { params: Record<string, string> } | null;\n}\n\nexport interface RouteMatchResult {\n  Component: ComponentType<any>;\n  params: Record<string, string>;\n  reducerKey?: string;\n}\n\ntype NormalizedRoute = {\n  path: string;\n  Component: ComponentType<any>;\n  reducerKey?: string;\n};\n\nconst isPreparedRouteArray = (\n  routes: RoutesInput | PreparedRoute[],\n): routes is PreparedRoute[] =>\n  Array.isArray(routes) &&\n  routes.every((route) => typeof route === \"object\" && typeof (route as PreparedRoute).matcher === \"function\");\n\nconst escapeRegex = (s: string): string => s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\nconst decodeParam = (value: string): string => {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n};\n\n// Compile a path pattern like \"/users/:id\" into a RegExp with capture groups.\n// Supports \"*\" or \"/*\" catch-all and \":param+\" rest parameters.\nconst compilePath = (path: string): { regex: RegExp; names: string[] } => {\n  if (!path || path === \"/\") {\n    return { regex: /^\\/?$/, names: [] };\n  }\n  if (path === \"*\" || path === \"/*\") {\n    return { regex: /^.*$/, names: [] };\n  }\n\n  const parts: Array<{ src: string; name: string | null }> = String(path)\n    .split(\"/\")\n    .filter(Boolean)\n    .map((part) => {\n      if (part.startsWith(\":\")) {\n        const raw = part.slice(1).trim();\n        const modifier = raw[raw.length - 1];\n        const hasModifier = modifier === \"+\" || modifier === \"*\" || modifier === \"?\";\n        const name = (hasModifier ? raw.slice(0, -1) : raw).trim();\n\n        if (!name) {\n          throw new TypeError(`Invalid route param segment \\\"${part}\\\" in path \\\"${path}\\\"`);\n        }\n\n        // Use plain captures so invalid JS identifier characters in route params do not break regex compilation.\n        const src = modifier === \"+\" ? \"(.+)\" : \"([^/]+)\";\n        return { src, name };\n      }\n      return { src: escapeRegex(part), name: null };\n    });\n\n  const pattern = \"^/\" + parts.map((p) => p.src).join(\"/\") + \"/?$\";\n  const names = parts.filter((p) => p.name).map((p) => p.name as string);\n  return { regex: new RegExp(pattern), names };\n};\n\n// Graceful 404 Component that renders the text \"404\" (no React import required)\nconst Generic404 = (): string => \"404\";\n\n// Normalize a single map entry: (path, value) -> { path, Component, reducerKey }\nconst normalizeMapEntry = (path: string, value: RouteMapValue): NormalizedRoute => {\n  let Component: ComponentType<any>;\n  let reducerKey: string | undefined;\n\n  if (Array.isArray(value)) {\n    [Component, reducerKey] = value;\n  } else if (typeof value === \"function\") {\n    Component = value;\n  } else if (value && typeof value === \"object\") {\n    Component = value.Component || value.element || value.render || (() => null);\n    reducerKey = value.reducerKey;\n  } else {\n    Component = () => null;\n  }\n\n  return { path, Component, reducerKey };\n};\n\n// Normalize a route object from array form: { path, Component | element | render, reducerKey? }\nconst normalizeArrayEntry = (routeObj: RouteDefinition = { path: \"/\" }): NormalizedRoute => {\n  const { path = \"/\", reducerKey } = routeObj;\n  const Component = routeObj.Component || routeObj.element || routeObj.render || (() => null);\n  return { path, Component, reducerKey };\n};\n\n// Convert routes (array or map) into a uniform list of { path, Component, reducerKey }\nconst toList = (routes: RoutesInput): NormalizedRoute[] => {\n  if (Array.isArray(routes)) {\n    return routes.map(normalizeArrayEntry);\n  }\n\n  return Object.entries(routes).map(([path, value]) => normalizeMapEntry(path, value));\n};\n\n// Public: prepare routes by attaching a matcher to each entry.\nexport const prepare = (routes: RoutesInput = []): PreparedRoute[] => {\n  const list = toList(routes);\n\n  return list.map((r) => {\n    // Catch-all\n    if (r.path === \"*\" || r.path === \"/*\") {\n      return { ...r, matcher: () => ({ params: {} }) };\n    }\n\n    const { regex, names } = compilePath(r.path);\n    const matcher = (pathname: string): { params: Record<string, string> } | null => {\n      const m = regex.exec(pathname);\n      if (!m) return null;\n\n      const params = names.reduce<Record<string, string>>((acc, name, i) => {\n        acc[name] = decodeParam(m[i + 1]);\n        return acc;\n      }, {});\n\n      return { params };\n    };\n\n    return { ...r, matcher };\n  });\n};\n\n// Internal: find a match in a prepared list\nconst matchOne = (preparedRoutes: PreparedRoute[], pathname: string): RouteMatchResult => {\n  for (const r of preparedRoutes) {\n    if (typeof r.matcher !== \"function\") continue;\n    const res = r.matcher(pathname);\n    if (res) {\n      return {\n        Component: r.Component,\n        params: res.params || {},\n        reducerKey: r.reducerKey,\n      };\n    }\n  }\n\n  // Catch-all fallback if provided\n  const star = preparedRoutes.find((r) => r.path === \"*\" || r.path === \"/*\");\n  if (star) {\n    return {\n      Component: star.Component,\n      params: {},\n      reducerKey: star.reducerKey,\n    };\n  }\n\n  // Generic 404 fallback\n  return { Component: Generic404, params: {} };\n};\n\n// Public: match() accepts either raw routes or an already-prepared list\nexport const match = (\n  routes: RoutesInput | PreparedRoute[],\n  pathname: string,\n): RouteMatchResult => {\n  const prepared = isPreparedRouteArray(routes) ? routes : prepare(routes);\n  return matchOne(prepared, pathname);\n};\n\nexport default { prepare, match };\n","// Centralized scroll helpers with query-aware keys\nconst SCROLL_KEY = \"scroll\";\nconst MAX_SCROLL_ENTRIES = 100;\n\nexport interface ScrollPosition {\n  x: number;\n  y: number;\n}\n\nexport const getScrollPosition = (): ScrollPosition => ({\n  y: window.pageYOffset || document.documentElement.scrollTop || 0,\n  x: window.pageXOffset || document.documentElement.scrollLeft || 0,\n});\n\nconst currentKey = (): string => {\n  const { pathname, search } = window.location;\n  return `${pathname}${search || \"\"}`;\n};\n\nconst readStore = (): Record<string, ScrollPosition> => {\n  if (typeof sessionStorage === \"undefined\") return {};\n  try {\n    const blob = sessionStorage.getItem(SCROLL_KEY);\n    return blob ? (JSON.parse(blob) as Record<string, ScrollPosition>) : {};\n  } catch {\n    return {};\n  }\n};\n\nconst writeStore = (obj: Record<string, ScrollPosition>): void => {\n  if (typeof sessionStorage === \"undefined\") return;\n  try {\n    const keys = Object.keys(obj);\n    if (keys.length > MAX_SCROLL_ENTRIES) {\n      const excess = keys.length - MAX_SCROLL_ENTRIES;\n      for (let i = 0; i < excess; i += 1) {\n        delete obj[keys[i]];\n      }\n    }\n    sessionStorage.setItem(SCROLL_KEY, JSON.stringify(obj));\n  } catch {\n    /* ignore quota/security errors */\n  }\n};\n\nexport const setScrollToSessionStorage = (): void => {\n  const store = readStore();\n  const key = currentKey();\n  if (store[key]) delete store[key];\n  store[key] = getScrollPosition();\n  writeStore(store);\n};\n\nexport const setScrollForKey = (key: string, pos?: ScrollPosition): void => {\n  const store = readStore();\n  if (store[key]) delete store[key];\n  store[key] = pos || getScrollPosition();\n  writeStore(store);\n};\n\nexport function getScrollFromSessionStorage(key: \"*\"): Record<string, ScrollPosition>;\nexport function getScrollFromSessionStorage(key: string): ScrollPosition | null;\nexport function getScrollFromSessionStorage(\n  key?: string,\n): Record<string, ScrollPosition> | ScrollPosition | null {\n  const store = readStore();\n  if (key === \"*\" || key === undefined) return store;\n  return store[key] || null;\n}\n","import type { BrowserHistory, Update } from \"history\";\nimport { getScrollFromSessionStorage, type ScrollPosition } from \"./scroll\";\n\nexport interface ProgressAPI {\n  start(): void;\n  done(): void;\n}\n\nexport interface HandleHistoryChangeOptions {\n  history?: BrowserHistory | null;\n  fetchImpl?: ((url: string, init?: RequestInit) => Promise<Response>) | null;\n  setTitle?: (title: string) => void;\n  progress?: ProgressAPI;\n}\n\nconst makeUuid = (): string => {\n  // Browser / Workers\n  if (typeof globalThis !== \"undefined\" && globalThis.crypto) {\n    if (typeof globalThis.crypto.randomUUID === \"function\") {\n      return globalThis.crypto.randomUUID();\n    }\n    // RFC4122 v4 via getRandomValues\n    const buf = new Uint8Array(16);\n    globalThis.crypto.getRandomValues(buf);\n    buf[6] = (buf[6] & 0x0f) | 0x40;\n    buf[8] = (buf[8] & 0x3f) | 0x80;\n    const hex = [...buf].map((b) => b.toString(16).padStart(2, \"0\"));\n    return `${hex.slice(0, 4).join(\"\")}-${hex.slice(4, 6).join(\"\")}-${hex\n      .slice(6, 8)\n      .join(\"\")}-${hex.slice(8, 10).join(\"\")}-${hex.slice(10).join(\"\")}`;\n  }\n  // Node\n  try {\n    const { randomUUID } = (globalThis as any).require(\"node:crypto\");\n    if (typeof randomUUID === \"function\") return randomUUID();\n  } catch {}\n  // Last-resort (non-crypto)\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nconst INSTALLED = Symbol.for(\"handleHistoryChange:installed\");\nlet _inFlight: AbortController | null = null;\nlet _latestRequestId: number = 0;\nlet _scrollRestoreTimeout: ReturnType<typeof setTimeout> | null = null;\n\nconst clearScrollRestoreTimeout = (): void => {\n  if (_scrollRestoreTimeout) {\n    clearTimeout(_scrollRestoreTimeout);\n    _scrollRestoreTimeout = null;\n  }\n};\n\nconst originOf = (): string => {\n  try {\n    if (\n      typeof window !== \"undefined\" &&\n      window.location &&\n      window.location.origin\n    ) {\n      return window.location.origin;\n    }\n  } catch {}\n  return \"http://localhost\";\n};\n\nconst buildUrl = (loc: { pathname?: string; search?: string }): string => {\n  const url = new URL((loc.pathname || \"/\") + (loc.search || \"\"), originOf());\n  url.searchParams.set(\"uuid\", makeUuid());\n  return url.toString();\n};\n\nconst kindFrom = (status: number): \"ok\" | \"404\" | \"5xx\" => {\n  if (status === 404) return \"404\";\n  if (Math.floor(status / 100) === 5) return \"5xx\";\n  return \"ok\";\n};\n\nexport default function handleHistoryChange(\n  dispatch: (action: { type: string; data: Record<string, unknown> }) => void,\n  {\n    history,\n    fetchImpl = (typeof fetch !== \"undefined\" && fetch) || null,\n    setTitle = function (t: string): void {\n      if (typeof document !== \"undefined\" && t) document.title = t;\n    },\n    progress = { start() {}, done() {} }, // optional in tests\n  }: HandleHistoryChangeOptions = {},\n): () => void {\n  if (!history || !fetchImpl) {\n    return () => {};\n  }\n\n  if ((history as any)[INSTALLED]) {\n    return () => {};\n  }\n  (history as any)[INSTALLED] = true;\n\n  const unlisten = history.listen(function ({ location, action }: Update): void {\n    // Abort prior request\n    if (_inFlight && typeof _inFlight.abort === \"function\") {\n      try {\n        _inFlight.abort();\n      } catch {}\n    }\n    clearScrollRestoreTimeout();\n    const requestId = ++_latestRequestId;\n    _inFlight =\n      typeof AbortController !== \"undefined\" ? new AbortController() : null;\n\n    if (progress && typeof progress.done === \"function\") progress.done();\n    if (progress && typeof progress.start === \"function\") progress.start();\n\n    const url = buildUrl(location);\n\n    // Single promise chain so one microtask drain should be enough in tests\n    Promise.resolve(\n      fetchImpl(url, {\n        method: \"GET\",\n        headers: { Accept: \"application/json\" },\n        signal: _inFlight ? _inFlight.signal : undefined,\n      }),\n    )\n      .then(function (res): Promise<{ status: number; data: Record<string, unknown> }> {\n        const jp = res && res.json ? res.json() : {};\n        return Promise.resolve(jp)\n          .then(function (data) {\n            return { status: res ? res.status : 503, data: (data as Record<string, unknown>) || {} };\n          })\n          .catch(function () {\n            return { status: res ? res.status : 503, data: {} };\n          });\n      })\n      .catch(function () {\n        return { status: 503, data: {} };\n      })\n      .then(function ({ status, data }): void {\n        if (requestId !== _latestRequestId) return;\n        if (progress && typeof progress.done === \"function\") progress.done();\n\n        // Authorization redirect wins\n        const authLoc = (data as { authorization?: { location?: string } }).authorization\n          ?.location;\n        let finalLoc = authLoc || location.pathname || \"/\";\n\n        // Map 404/5xx if no explicit auth redirect\n        if (!authLoc) {\n          const k = kindFrom(status);\n          if (k === \"404\") finalLoc = \"/404\";\n          else if (k === \"5xx\") finalLoc = \"/500\";\n        }\n\n        dispatch({\n          type: \"CHANGE_PAGE\",\n          data: Object.assign({}, data, { location: finalLoc }),\n        });\n\n        // Title from top-level data.title\n        const title = (data as { title?: string }).title;\n        if (title) {\n          // eslint-disable-next-line no-console\n          setTitle(title);\n        }\n\n        // Scroll behavior: top on PUSH; restore for POP/REPLACE\n        if (typeof window !== \"undefined\" && window.scrollTo) {\n          if (action === \"PUSH\") {\n            window.scrollTo(0, 0);\n          } else {\n            const key = (location.pathname || \"/\") + (location.search || \"\");\n            const prev: ScrollPosition | null = getScrollFromSessionStorage(key);\n            if (prev) {\n              _scrollRestoreTimeout = setTimeout(function () {\n                window.scrollTo(prev.x || 0, prev.y || 0);\n                _scrollRestoreTimeout = null;\n              }, 250);\n            }\n          }\n        }\n      });\n  });\n\n  return (): void => {\n    if (typeof unlisten === \"function\") unlisten();\n    clearScrollRestoreTimeout();\n    if (_inFlight && typeof _inFlight.abort === \"function\") {\n      try {\n        _inFlight.abort();\n      } catch {}\n    }\n    _inFlight = null;\n    (history as any)[INSTALLED] = false;\n  };\n}\n\n// Test helpers (reset does nothing now because the guard is per-history instance)\nexport const __test__: {\n  reset: () => void;\n  state: () => { inFlight: boolean };\n} = {\n  reset: function (): void {\n    _latestRequestId = 0;\n    _inFlight = null;\n    clearScrollRestoreTimeout();\n  },\n  state: function (): { inFlight: boolean } {\n    return {\n      inFlight: !!_inFlight,\n    };\n  },\n};\n"],"mappings":"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","names":["appHistory"]}